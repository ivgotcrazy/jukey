// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_user_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_user_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_user_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_user_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_user_2eproto;
namespace jukey {
namespace prot {
class UserLoginReq;
struct UserLoginReqDefaultTypeInternal;
extern UserLoginReqDefaultTypeInternal _UserLoginReq_default_instance_;
class UserLoginRsp;
struct UserLoginRspDefaultTypeInternal;
extern UserLoginRspDefaultTypeInternal _UserLoginRsp_default_instance_;
class UserLogoutReq;
struct UserLogoutReqDefaultTypeInternal;
extern UserLogoutReqDefaultTypeInternal _UserLogoutReq_default_instance_;
class UserLogoutRsp;
struct UserLogoutRspDefaultTypeInternal;
extern UserLogoutRspDefaultTypeInternal _UserLogoutRsp_default_instance_;
class UserOfflineNotify;
struct UserOfflineNotifyDefaultTypeInternal;
extern UserOfflineNotifyDefaultTypeInternal _UserOfflineNotify_default_instance_;
}  // namespace prot
}  // namespace jukey
PROTOBUF_NAMESPACE_OPEN
template<> ::jukey::prot::UserLoginReq* Arena::CreateMaybeMessage<::jukey::prot::UserLoginReq>(Arena*);
template<> ::jukey::prot::UserLoginRsp* Arena::CreateMaybeMessage<::jukey::prot::UserLoginRsp>(Arena*);
template<> ::jukey::prot::UserLogoutReq* Arena::CreateMaybeMessage<::jukey::prot::UserLogoutReq>(Arena*);
template<> ::jukey::prot::UserLogoutRsp* Arena::CreateMaybeMessage<::jukey::prot::UserLogoutRsp>(Arena*);
template<> ::jukey::prot::UserOfflineNotify* Arena::CreateMaybeMessage<::jukey::prot::UserOfflineNotify>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace jukey {
namespace prot {

// ===================================================================

class UserLoginReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.UserLoginReq) */ {
 public:
  inline UserLoginReq() : UserLoginReq(nullptr) {}
  ~UserLoginReq() override;
  explicit PROTOBUF_CONSTEXPR UserLoginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserLoginReq(const UserLoginReq& from);
  UserLoginReq(UserLoginReq&& from) noexcept
    : UserLoginReq() {
    *this = ::std::move(from);
  }

  inline UserLoginReq& operator=(const UserLoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLoginReq& operator=(UserLoginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLoginReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLoginReq* internal_default_instance() {
    return reinterpret_cast<const UserLoginReq*>(
               &_UserLoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UserLoginReq& a, UserLoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLoginReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLoginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLoginReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserLoginReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserLoginReq& from) {
    UserLoginReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLoginReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.UserLoginReq";
  }
  protected:
  explicit UserLoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 6,
    kAppIdFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kRegisterIdFieldNumber = 3,
    kUserTypeFieldNumber = 4,
    kUserIdFieldNumber = 5,
  };
  // required string token = 6;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 client_id = 2;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint32_t client_id() const;
  void set_client_id(uint32_t value);
  private:
  uint32_t _internal_client_id() const;
  void _internal_set_client_id(uint32_t value);
  public:

  // required uint32 register_id = 3;
  bool has_register_id() const;
  private:
  bool _internal_has_register_id() const;
  public:
  void clear_register_id();
  uint32_t register_id() const;
  void set_register_id(uint32_t value);
  private:
  uint32_t _internal_register_id() const;
  void _internal_set_register_id(uint32_t value);
  public:

  // required uint32 user_type = 4;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 5;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.UserLoginReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    uint32_t app_id_;
    uint32_t client_id_;
    uint32_t register_id_;
    uint32_t user_type_;
    uint32_t user_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class UserLoginRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.UserLoginRsp) */ {
 public:
  inline UserLoginRsp() : UserLoginRsp(nullptr) {}
  ~UserLoginRsp() override;
  explicit PROTOBUF_CONSTEXPR UserLoginRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserLoginRsp(const UserLoginRsp& from);
  UserLoginRsp(UserLoginRsp&& from) noexcept
    : UserLoginRsp() {
    *this = ::std::move(from);
  }

  inline UserLoginRsp& operator=(const UserLoginRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLoginRsp& operator=(UserLoginRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLoginRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLoginRsp* internal_default_instance() {
    return reinterpret_cast<const UserLoginRsp*>(
               &_UserLoginRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserLoginRsp& a, UserLoginRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLoginRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLoginRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLoginRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLoginRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserLoginRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserLoginRsp& from) {
    UserLoginRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLoginRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.UserLoginRsp";
  }
  protected:
  explicit UserLoginRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 8,
    kAppIdFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kRegisterIdFieldNumber = 3,
    kUserTypeFieldNumber = 4,
    kUserIdFieldNumber = 5,
    kLoginIdFieldNumber = 6,
    kResultFieldNumber = 7,
  };
  // required string msg = 8;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 client_id = 2;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint32_t client_id() const;
  void set_client_id(uint32_t value);
  private:
  uint32_t _internal_client_id() const;
  void _internal_set_client_id(uint32_t value);
  public:

  // required uint32 register_id = 3;
  bool has_register_id() const;
  private:
  bool _internal_has_register_id() const;
  public:
  void clear_register_id();
  uint32_t register_id() const;
  void set_register_id(uint32_t value);
  private:
  uint32_t _internal_register_id() const;
  void _internal_set_register_id(uint32_t value);
  public:

  // required uint32 user_type = 4;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 5;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 login_id = 6;
  bool has_login_id() const;
  private:
  bool _internal_has_login_id() const;
  public:
  void clear_login_id();
  uint32_t login_id() const;
  void set_login_id(uint32_t value);
  private:
  uint32_t _internal_login_id() const;
  void _internal_set_login_id(uint32_t value);
  public:

  // required uint32 result = 7;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.UserLoginRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    uint32_t app_id_;
    uint32_t client_id_;
    uint32_t register_id_;
    uint32_t user_type_;
    uint32_t user_id_;
    uint32_t login_id_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class UserLogoutReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.UserLogoutReq) */ {
 public:
  inline UserLogoutReq() : UserLogoutReq(nullptr) {}
  ~UserLogoutReq() override;
  explicit PROTOBUF_CONSTEXPR UserLogoutReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserLogoutReq(const UserLogoutReq& from);
  UserLogoutReq(UserLogoutReq&& from) noexcept
    : UserLogoutReq() {
    *this = ::std::move(from);
  }

  inline UserLogoutReq& operator=(const UserLogoutReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLogoutReq& operator=(UserLogoutReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLogoutReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLogoutReq* internal_default_instance() {
    return reinterpret_cast<const UserLogoutReq*>(
               &_UserLogoutReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserLogoutReq& a, UserLogoutReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLogoutReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLogoutReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLogoutReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLogoutReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserLogoutReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserLogoutReq& from) {
    UserLogoutReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLogoutReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.UserLogoutReq";
  }
  protected:
  explicit UserLogoutReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 7,
    kAppIdFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kRegisterIdFieldNumber = 3,
    kUserTypeFieldNumber = 4,
    kUserIdFieldNumber = 5,
    kLoginIdFieldNumber = 6,
  };
  // required string token = 7;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 client_id = 2;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint32_t client_id() const;
  void set_client_id(uint32_t value);
  private:
  uint32_t _internal_client_id() const;
  void _internal_set_client_id(uint32_t value);
  public:

  // required uint32 register_id = 3;
  bool has_register_id() const;
  private:
  bool _internal_has_register_id() const;
  public:
  void clear_register_id();
  uint32_t register_id() const;
  void set_register_id(uint32_t value);
  private:
  uint32_t _internal_register_id() const;
  void _internal_set_register_id(uint32_t value);
  public:

  // required uint32 user_type = 4;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 5;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 login_id = 6;
  bool has_login_id() const;
  private:
  bool _internal_has_login_id() const;
  public:
  void clear_login_id();
  uint32_t login_id() const;
  void set_login_id(uint32_t value);
  private:
  uint32_t _internal_login_id() const;
  void _internal_set_login_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.UserLogoutReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    uint32_t app_id_;
    uint32_t client_id_;
    uint32_t register_id_;
    uint32_t user_type_;
    uint32_t user_id_;
    uint32_t login_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class UserLogoutRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.UserLogoutRsp) */ {
 public:
  inline UserLogoutRsp() : UserLogoutRsp(nullptr) {}
  ~UserLogoutRsp() override;
  explicit PROTOBUF_CONSTEXPR UserLogoutRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserLogoutRsp(const UserLogoutRsp& from);
  UserLogoutRsp(UserLogoutRsp&& from) noexcept
    : UserLogoutRsp() {
    *this = ::std::move(from);
  }

  inline UserLogoutRsp& operator=(const UserLogoutRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLogoutRsp& operator=(UserLogoutRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLogoutRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLogoutRsp* internal_default_instance() {
    return reinterpret_cast<const UserLogoutRsp*>(
               &_UserLogoutRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UserLogoutRsp& a, UserLogoutRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLogoutRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLogoutRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLogoutRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLogoutRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserLogoutRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserLogoutRsp& from) {
    UserLogoutRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLogoutRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.UserLogoutRsp";
  }
  protected:
  explicit UserLogoutRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 8,
    kAppIdFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kRegisterIdFieldNumber = 3,
    kUserTypeFieldNumber = 4,
    kUserIdFieldNumber = 5,
    kLoginIdFieldNumber = 6,
    kResultFieldNumber = 7,
  };
  // required string msg = 8;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 client_id = 2;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint32_t client_id() const;
  void set_client_id(uint32_t value);
  private:
  uint32_t _internal_client_id() const;
  void _internal_set_client_id(uint32_t value);
  public:

  // required uint32 register_id = 3;
  bool has_register_id() const;
  private:
  bool _internal_has_register_id() const;
  public:
  void clear_register_id();
  uint32_t register_id() const;
  void set_register_id(uint32_t value);
  private:
  uint32_t _internal_register_id() const;
  void _internal_set_register_id(uint32_t value);
  public:

  // required uint32 user_type = 4;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 5;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 login_id = 6;
  bool has_login_id() const;
  private:
  bool _internal_has_login_id() const;
  public:
  void clear_login_id();
  uint32_t login_id() const;
  void set_login_id(uint32_t value);
  private:
  uint32_t _internal_login_id() const;
  void _internal_set_login_id(uint32_t value);
  public:

  // required uint32 result = 7;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.UserLogoutRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    uint32_t app_id_;
    uint32_t client_id_;
    uint32_t register_id_;
    uint32_t user_type_;
    uint32_t user_id_;
    uint32_t login_id_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class UserOfflineNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.UserOfflineNotify) */ {
 public:
  inline UserOfflineNotify() : UserOfflineNotify(nullptr) {}
  ~UserOfflineNotify() override;
  explicit PROTOBUF_CONSTEXPR UserOfflineNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserOfflineNotify(const UserOfflineNotify& from);
  UserOfflineNotify(UserOfflineNotify&& from) noexcept
    : UserOfflineNotify() {
    *this = ::std::move(from);
  }

  inline UserOfflineNotify& operator=(const UserOfflineNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserOfflineNotify& operator=(UserOfflineNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserOfflineNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserOfflineNotify* internal_default_instance() {
    return reinterpret_cast<const UserOfflineNotify*>(
               &_UserOfflineNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UserOfflineNotify& a, UserOfflineNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(UserOfflineNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserOfflineNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserOfflineNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserOfflineNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserOfflineNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserOfflineNotify& from) {
    UserOfflineNotify::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserOfflineNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.UserOfflineNotify";
  }
  protected:
  explicit UserOfflineNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kRegisterIdFieldNumber = 3,
    kUserTypeFieldNumber = 4,
    kUserIdFieldNumber = 5,
    kLoginIdFieldNumber = 6,
  };
  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 client_id = 2;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint32_t client_id() const;
  void set_client_id(uint32_t value);
  private:
  uint32_t _internal_client_id() const;
  void _internal_set_client_id(uint32_t value);
  public:

  // required uint32 register_id = 3;
  bool has_register_id() const;
  private:
  bool _internal_has_register_id() const;
  public:
  void clear_register_id();
  uint32_t register_id() const;
  void set_register_id(uint32_t value);
  private:
  uint32_t _internal_register_id() const;
  void _internal_set_register_id(uint32_t value);
  public:

  // required uint32 user_type = 4;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 5;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 login_id = 6;
  bool has_login_id() const;
  private:
  bool _internal_has_login_id() const;
  public:
  void clear_login_id();
  uint32_t login_id() const;
  void set_login_id(uint32_t value);
  private:
  uint32_t _internal_login_id() const;
  void _internal_set_login_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.UserOfflineNotify)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t app_id_;
    uint32_t client_id_;
    uint32_t register_id_;
    uint32_t user_type_;
    uint32_t user_id_;
    uint32_t login_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserLoginReq

// required uint32 app_id = 1;
inline bool UserLoginReq::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserLoginReq::has_app_id() const {
  return _internal_has_app_id();
}
inline void UserLoginReq::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t UserLoginReq::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t UserLoginReq::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLoginReq.app_id)
  return _internal_app_id();
}
inline void UserLoginReq::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_id_ = value;
}
inline void UserLoginReq::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLoginReq.app_id)
}

// required uint32 client_id = 2;
inline bool UserLoginReq::_internal_has_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserLoginReq::has_client_id() const {
  return _internal_has_client_id();
}
inline void UserLoginReq::clear_client_id() {
  _impl_.client_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UserLoginReq::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint32_t UserLoginReq::client_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLoginReq.client_id)
  return _internal_client_id();
}
inline void UserLoginReq::_internal_set_client_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.client_id_ = value;
}
inline void UserLoginReq::set_client_id(uint32_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLoginReq.client_id)
}

// required uint32 register_id = 3;
inline bool UserLoginReq::_internal_has_register_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserLoginReq::has_register_id() const {
  return _internal_has_register_id();
}
inline void UserLoginReq::clear_register_id() {
  _impl_.register_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t UserLoginReq::_internal_register_id() const {
  return _impl_.register_id_;
}
inline uint32_t UserLoginReq::register_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLoginReq.register_id)
  return _internal_register_id();
}
inline void UserLoginReq::_internal_set_register_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.register_id_ = value;
}
inline void UserLoginReq::set_register_id(uint32_t value) {
  _internal_set_register_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLoginReq.register_id)
}

// required uint32 user_type = 4;
inline bool UserLoginReq::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserLoginReq::has_user_type() const {
  return _internal_has_user_type();
}
inline void UserLoginReq::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t UserLoginReq::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t UserLoginReq::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLoginReq.user_type)
  return _internal_user_type();
}
inline void UserLoginReq::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_type_ = value;
}
inline void UserLoginReq::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLoginReq.user_type)
}

// required uint32 user_id = 5;
inline bool UserLoginReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UserLoginReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void UserLoginReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t UserLoginReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UserLoginReq::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLoginReq.user_id)
  return _internal_user_id();
}
inline void UserLoginReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.user_id_ = value;
}
inline void UserLoginReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLoginReq.user_id)
}

// required string token = 6;
inline bool UserLoginReq::_internal_has_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserLoginReq::has_token() const {
  return _internal_has_token();
}
inline void UserLoginReq::clear_token() {
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserLoginReq::token() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLoginReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLoginReq::set_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.UserLoginReq.token)
}
inline std::string* UserLoginReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:jukey.prot.UserLoginReq.token)
  return _s;
}
inline const std::string& UserLoginReq::_internal_token() const {
  return _impl_.token_.Get();
}
inline void UserLoginReq::_internal_set_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLoginReq::_internal_mutable_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLoginReq::release_token() {
  // @@protoc_insertion_point(field_release:jukey.prot.UserLoginReq.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserLoginReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.UserLoginReq.token)
}

// -------------------------------------------------------------------

// UserLoginRsp

// required uint32 app_id = 1;
inline bool UserLoginRsp::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserLoginRsp::has_app_id() const {
  return _internal_has_app_id();
}
inline void UserLoginRsp::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t UserLoginRsp::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t UserLoginRsp::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLoginRsp.app_id)
  return _internal_app_id();
}
inline void UserLoginRsp::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_id_ = value;
}
inline void UserLoginRsp::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLoginRsp.app_id)
}

// required uint32 client_id = 2;
inline bool UserLoginRsp::_internal_has_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserLoginRsp::has_client_id() const {
  return _internal_has_client_id();
}
inline void UserLoginRsp::clear_client_id() {
  _impl_.client_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UserLoginRsp::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint32_t UserLoginRsp::client_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLoginRsp.client_id)
  return _internal_client_id();
}
inline void UserLoginRsp::_internal_set_client_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.client_id_ = value;
}
inline void UserLoginRsp::set_client_id(uint32_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLoginRsp.client_id)
}

// required uint32 register_id = 3;
inline bool UserLoginRsp::_internal_has_register_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserLoginRsp::has_register_id() const {
  return _internal_has_register_id();
}
inline void UserLoginRsp::clear_register_id() {
  _impl_.register_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t UserLoginRsp::_internal_register_id() const {
  return _impl_.register_id_;
}
inline uint32_t UserLoginRsp::register_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLoginRsp.register_id)
  return _internal_register_id();
}
inline void UserLoginRsp::_internal_set_register_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.register_id_ = value;
}
inline void UserLoginRsp::set_register_id(uint32_t value) {
  _internal_set_register_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLoginRsp.register_id)
}

// required uint32 user_type = 4;
inline bool UserLoginRsp::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserLoginRsp::has_user_type() const {
  return _internal_has_user_type();
}
inline void UserLoginRsp::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t UserLoginRsp::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t UserLoginRsp::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLoginRsp.user_type)
  return _internal_user_type();
}
inline void UserLoginRsp::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_type_ = value;
}
inline void UserLoginRsp::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLoginRsp.user_type)
}

// required uint32 user_id = 5;
inline bool UserLoginRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UserLoginRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void UserLoginRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t UserLoginRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UserLoginRsp::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLoginRsp.user_id)
  return _internal_user_id();
}
inline void UserLoginRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.user_id_ = value;
}
inline void UserLoginRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLoginRsp.user_id)
}

// required uint32 login_id = 6;
inline bool UserLoginRsp::_internal_has_login_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool UserLoginRsp::has_login_id() const {
  return _internal_has_login_id();
}
inline void UserLoginRsp::clear_login_id() {
  _impl_.login_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t UserLoginRsp::_internal_login_id() const {
  return _impl_.login_id_;
}
inline uint32_t UserLoginRsp::login_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLoginRsp.login_id)
  return _internal_login_id();
}
inline void UserLoginRsp::_internal_set_login_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.login_id_ = value;
}
inline void UserLoginRsp::set_login_id(uint32_t value) {
  _internal_set_login_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLoginRsp.login_id)
}

// required uint32 result = 7;
inline bool UserLoginRsp::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool UserLoginRsp::has_result() const {
  return _internal_has_result();
}
inline void UserLoginRsp::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t UserLoginRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t UserLoginRsp::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLoginRsp.result)
  return _internal_result();
}
inline void UserLoginRsp::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.result_ = value;
}
inline void UserLoginRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLoginRsp.result)
}

// required string msg = 8;
inline bool UserLoginRsp::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserLoginRsp::has_msg() const {
  return _internal_has_msg();
}
inline void UserLoginRsp::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserLoginRsp::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLoginRsp.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLoginRsp::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.UserLoginRsp.msg)
}
inline std::string* UserLoginRsp::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.UserLoginRsp.msg)
  return _s;
}
inline const std::string& UserLoginRsp::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void UserLoginRsp::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLoginRsp::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLoginRsp::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.UserLoginRsp.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserLoginRsp::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.UserLoginRsp.msg)
}

// -------------------------------------------------------------------

// UserLogoutReq

// required uint32 app_id = 1;
inline bool UserLogoutReq::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserLogoutReq::has_app_id() const {
  return _internal_has_app_id();
}
inline void UserLogoutReq::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t UserLogoutReq::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t UserLogoutReq::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLogoutReq.app_id)
  return _internal_app_id();
}
inline void UserLogoutReq::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_id_ = value;
}
inline void UserLogoutReq::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLogoutReq.app_id)
}

// required uint32 client_id = 2;
inline bool UserLogoutReq::_internal_has_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserLogoutReq::has_client_id() const {
  return _internal_has_client_id();
}
inline void UserLogoutReq::clear_client_id() {
  _impl_.client_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UserLogoutReq::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint32_t UserLogoutReq::client_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLogoutReq.client_id)
  return _internal_client_id();
}
inline void UserLogoutReq::_internal_set_client_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.client_id_ = value;
}
inline void UserLogoutReq::set_client_id(uint32_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLogoutReq.client_id)
}

// required uint32 register_id = 3;
inline bool UserLogoutReq::_internal_has_register_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserLogoutReq::has_register_id() const {
  return _internal_has_register_id();
}
inline void UserLogoutReq::clear_register_id() {
  _impl_.register_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t UserLogoutReq::_internal_register_id() const {
  return _impl_.register_id_;
}
inline uint32_t UserLogoutReq::register_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLogoutReq.register_id)
  return _internal_register_id();
}
inline void UserLogoutReq::_internal_set_register_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.register_id_ = value;
}
inline void UserLogoutReq::set_register_id(uint32_t value) {
  _internal_set_register_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLogoutReq.register_id)
}

// required uint32 user_type = 4;
inline bool UserLogoutReq::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserLogoutReq::has_user_type() const {
  return _internal_has_user_type();
}
inline void UserLogoutReq::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t UserLogoutReq::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t UserLogoutReq::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLogoutReq.user_type)
  return _internal_user_type();
}
inline void UserLogoutReq::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_type_ = value;
}
inline void UserLogoutReq::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLogoutReq.user_type)
}

// required uint32 user_id = 5;
inline bool UserLogoutReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UserLogoutReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void UserLogoutReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t UserLogoutReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UserLogoutReq::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLogoutReq.user_id)
  return _internal_user_id();
}
inline void UserLogoutReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.user_id_ = value;
}
inline void UserLogoutReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLogoutReq.user_id)
}

// required uint32 login_id = 6;
inline bool UserLogoutReq::_internal_has_login_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool UserLogoutReq::has_login_id() const {
  return _internal_has_login_id();
}
inline void UserLogoutReq::clear_login_id() {
  _impl_.login_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t UserLogoutReq::_internal_login_id() const {
  return _impl_.login_id_;
}
inline uint32_t UserLogoutReq::login_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLogoutReq.login_id)
  return _internal_login_id();
}
inline void UserLogoutReq::_internal_set_login_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.login_id_ = value;
}
inline void UserLogoutReq::set_login_id(uint32_t value) {
  _internal_set_login_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLogoutReq.login_id)
}

// required string token = 7;
inline bool UserLogoutReq::_internal_has_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserLogoutReq::has_token() const {
  return _internal_has_token();
}
inline void UserLogoutReq::clear_token() {
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserLogoutReq::token() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLogoutReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLogoutReq::set_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.UserLogoutReq.token)
}
inline std::string* UserLogoutReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:jukey.prot.UserLogoutReq.token)
  return _s;
}
inline const std::string& UserLogoutReq::_internal_token() const {
  return _impl_.token_.Get();
}
inline void UserLogoutReq::_internal_set_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLogoutReq::_internal_mutable_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLogoutReq::release_token() {
  // @@protoc_insertion_point(field_release:jukey.prot.UserLogoutReq.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserLogoutReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.UserLogoutReq.token)
}

// -------------------------------------------------------------------

// UserLogoutRsp

// required uint32 app_id = 1;
inline bool UserLogoutRsp::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserLogoutRsp::has_app_id() const {
  return _internal_has_app_id();
}
inline void UserLogoutRsp::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t UserLogoutRsp::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t UserLogoutRsp::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLogoutRsp.app_id)
  return _internal_app_id();
}
inline void UserLogoutRsp::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_id_ = value;
}
inline void UserLogoutRsp::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLogoutRsp.app_id)
}

// required uint32 client_id = 2;
inline bool UserLogoutRsp::_internal_has_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserLogoutRsp::has_client_id() const {
  return _internal_has_client_id();
}
inline void UserLogoutRsp::clear_client_id() {
  _impl_.client_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UserLogoutRsp::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint32_t UserLogoutRsp::client_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLogoutRsp.client_id)
  return _internal_client_id();
}
inline void UserLogoutRsp::_internal_set_client_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.client_id_ = value;
}
inline void UserLogoutRsp::set_client_id(uint32_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLogoutRsp.client_id)
}

// required uint32 register_id = 3;
inline bool UserLogoutRsp::_internal_has_register_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserLogoutRsp::has_register_id() const {
  return _internal_has_register_id();
}
inline void UserLogoutRsp::clear_register_id() {
  _impl_.register_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t UserLogoutRsp::_internal_register_id() const {
  return _impl_.register_id_;
}
inline uint32_t UserLogoutRsp::register_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLogoutRsp.register_id)
  return _internal_register_id();
}
inline void UserLogoutRsp::_internal_set_register_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.register_id_ = value;
}
inline void UserLogoutRsp::set_register_id(uint32_t value) {
  _internal_set_register_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLogoutRsp.register_id)
}

// required uint32 user_type = 4;
inline bool UserLogoutRsp::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserLogoutRsp::has_user_type() const {
  return _internal_has_user_type();
}
inline void UserLogoutRsp::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t UserLogoutRsp::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t UserLogoutRsp::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLogoutRsp.user_type)
  return _internal_user_type();
}
inline void UserLogoutRsp::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_type_ = value;
}
inline void UserLogoutRsp::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLogoutRsp.user_type)
}

// required uint32 user_id = 5;
inline bool UserLogoutRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UserLogoutRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void UserLogoutRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t UserLogoutRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UserLogoutRsp::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLogoutRsp.user_id)
  return _internal_user_id();
}
inline void UserLogoutRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.user_id_ = value;
}
inline void UserLogoutRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLogoutRsp.user_id)
}

// required uint32 login_id = 6;
inline bool UserLogoutRsp::_internal_has_login_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool UserLogoutRsp::has_login_id() const {
  return _internal_has_login_id();
}
inline void UserLogoutRsp::clear_login_id() {
  _impl_.login_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t UserLogoutRsp::_internal_login_id() const {
  return _impl_.login_id_;
}
inline uint32_t UserLogoutRsp::login_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLogoutRsp.login_id)
  return _internal_login_id();
}
inline void UserLogoutRsp::_internal_set_login_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.login_id_ = value;
}
inline void UserLogoutRsp::set_login_id(uint32_t value) {
  _internal_set_login_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLogoutRsp.login_id)
}

// required uint32 result = 7;
inline bool UserLogoutRsp::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool UserLogoutRsp::has_result() const {
  return _internal_has_result();
}
inline void UserLogoutRsp::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t UserLogoutRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t UserLogoutRsp::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLogoutRsp.result)
  return _internal_result();
}
inline void UserLogoutRsp::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.result_ = value;
}
inline void UserLogoutRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserLogoutRsp.result)
}

// required string msg = 8;
inline bool UserLogoutRsp::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserLogoutRsp::has_msg() const {
  return _internal_has_msg();
}
inline void UserLogoutRsp::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserLogoutRsp::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserLogoutRsp.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLogoutRsp::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.UserLogoutRsp.msg)
}
inline std::string* UserLogoutRsp::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.UserLogoutRsp.msg)
  return _s;
}
inline const std::string& UserLogoutRsp::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void UserLogoutRsp::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLogoutRsp::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLogoutRsp::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.UserLogoutRsp.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserLogoutRsp::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.UserLogoutRsp.msg)
}

// -------------------------------------------------------------------

// UserOfflineNotify

// required uint32 app_id = 1;
inline bool UserOfflineNotify::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserOfflineNotify::has_app_id() const {
  return _internal_has_app_id();
}
inline void UserOfflineNotify::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t UserOfflineNotify::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t UserOfflineNotify::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserOfflineNotify.app_id)
  return _internal_app_id();
}
inline void UserOfflineNotify::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_id_ = value;
}
inline void UserOfflineNotify::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserOfflineNotify.app_id)
}

// required uint32 client_id = 2;
inline bool UserOfflineNotify::_internal_has_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserOfflineNotify::has_client_id() const {
  return _internal_has_client_id();
}
inline void UserOfflineNotify::clear_client_id() {
  _impl_.client_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t UserOfflineNotify::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint32_t UserOfflineNotify::client_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserOfflineNotify.client_id)
  return _internal_client_id();
}
inline void UserOfflineNotify::_internal_set_client_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.client_id_ = value;
}
inline void UserOfflineNotify::set_client_id(uint32_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserOfflineNotify.client_id)
}

// required uint32 register_id = 3;
inline bool UserOfflineNotify::_internal_has_register_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserOfflineNotify::has_register_id() const {
  return _internal_has_register_id();
}
inline void UserOfflineNotify::clear_register_id() {
  _impl_.register_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UserOfflineNotify::_internal_register_id() const {
  return _impl_.register_id_;
}
inline uint32_t UserOfflineNotify::register_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserOfflineNotify.register_id)
  return _internal_register_id();
}
inline void UserOfflineNotify::_internal_set_register_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.register_id_ = value;
}
inline void UserOfflineNotify::set_register_id(uint32_t value) {
  _internal_set_register_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserOfflineNotify.register_id)
}

// required uint32 user_type = 4;
inline bool UserOfflineNotify::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserOfflineNotify::has_user_type() const {
  return _internal_has_user_type();
}
inline void UserOfflineNotify::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t UserOfflineNotify::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t UserOfflineNotify::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserOfflineNotify.user_type)
  return _internal_user_type();
}
inline void UserOfflineNotify::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_type_ = value;
}
inline void UserOfflineNotify::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserOfflineNotify.user_type)
}

// required uint32 user_id = 5;
inline bool UserOfflineNotify::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserOfflineNotify::has_user_id() const {
  return _internal_has_user_id();
}
inline void UserOfflineNotify::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t UserOfflineNotify::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UserOfflineNotify::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserOfflineNotify.user_id)
  return _internal_user_id();
}
inline void UserOfflineNotify::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_id_ = value;
}
inline void UserOfflineNotify::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserOfflineNotify.user_id)
}

// required uint32 login_id = 6;
inline bool UserOfflineNotify::_internal_has_login_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UserOfflineNotify::has_login_id() const {
  return _internal_has_login_id();
}
inline void UserOfflineNotify::clear_login_id() {
  _impl_.login_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t UserOfflineNotify::_internal_login_id() const {
  return _impl_.login_id_;
}
inline uint32_t UserOfflineNotify::login_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UserOfflineNotify.login_id)
  return _internal_login_id();
}
inline void UserOfflineNotify::_internal_set_login_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.login_id_ = value;
}
inline void UserOfflineNotify::set_login_id(uint32_t value) {
  _internal_set_login_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UserOfflineNotify.login_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace prot
}  // namespace jukey

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_user_2eproto
