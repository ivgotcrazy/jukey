// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: terminal.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_terminal_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_terminal_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_terminal_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_terminal_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_terminal_2eproto;
namespace jukey {
namespace prot {
class ClientOfflineNotify;
struct ClientOfflineNotifyDefaultTypeInternal;
extern ClientOfflineNotifyDefaultTypeInternal _ClientOfflineNotify_default_instance_;
class ClientOfflineReq;
struct ClientOfflineReqDefaultTypeInternal;
extern ClientOfflineReqDefaultTypeInternal _ClientOfflineReq_default_instance_;
class ClientOfflineRsp;
struct ClientOfflineRspDefaultTypeInternal;
extern ClientOfflineRspDefaultTypeInternal _ClientOfflineRsp_default_instance_;
class RegisterReq;
struct RegisterReqDefaultTypeInternal;
extern RegisterReqDefaultTypeInternal _RegisterReq_default_instance_;
class RegisterReqExtendData;
struct RegisterReqExtendDataDefaultTypeInternal;
extern RegisterReqExtendDataDefaultTypeInternal _RegisterReqExtendData_default_instance_;
class RegisterRsp;
struct RegisterRspDefaultTypeInternal;
extern RegisterRspDefaultTypeInternal _RegisterRsp_default_instance_;
class UnregisterReq;
struct UnregisterReqDefaultTypeInternal;
extern UnregisterReqDefaultTypeInternal _UnregisterReq_default_instance_;
class UnregisterRsp;
struct UnregisterRspDefaultTypeInternal;
extern UnregisterRspDefaultTypeInternal _UnregisterRsp_default_instance_;
}  // namespace prot
}  // namespace jukey
PROTOBUF_NAMESPACE_OPEN
template<> ::jukey::prot::ClientOfflineNotify* Arena::CreateMaybeMessage<::jukey::prot::ClientOfflineNotify>(Arena*);
template<> ::jukey::prot::ClientOfflineReq* Arena::CreateMaybeMessage<::jukey::prot::ClientOfflineReq>(Arena*);
template<> ::jukey::prot::ClientOfflineRsp* Arena::CreateMaybeMessage<::jukey::prot::ClientOfflineRsp>(Arena*);
template<> ::jukey::prot::RegisterReq* Arena::CreateMaybeMessage<::jukey::prot::RegisterReq>(Arena*);
template<> ::jukey::prot::RegisterReqExtendData* Arena::CreateMaybeMessage<::jukey::prot::RegisterReqExtendData>(Arena*);
template<> ::jukey::prot::RegisterRsp* Arena::CreateMaybeMessage<::jukey::prot::RegisterRsp>(Arena*);
template<> ::jukey::prot::UnregisterReq* Arena::CreateMaybeMessage<::jukey::prot::UnregisterReq>(Arena*);
template<> ::jukey::prot::UnregisterRsp* Arena::CreateMaybeMessage<::jukey::prot::UnregisterRsp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace jukey {
namespace prot {

// ===================================================================

class RegisterReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.RegisterReq) */ {
 public:
  inline RegisterReq() : RegisterReq(nullptr) {}
  ~RegisterReq() override;
  explicit PROTOBUF_CONSTEXPR RegisterReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterReq(const RegisterReq& from);
  RegisterReq(RegisterReq&& from) noexcept
    : RegisterReq() {
    *this = ::std::move(from);
  }

  inline RegisterReq& operator=(const RegisterReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterReq& operator=(RegisterReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterReq* internal_default_instance() {
    return reinterpret_cast<const RegisterReq*>(
               &_RegisterReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RegisterReq& a, RegisterReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterReq& from) {
    RegisterReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.RegisterReq";
  }
  protected:
  explicit RegisterReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 4,
    kOsFieldNumber = 5,
    kDeviceFieldNumber = 6,
    kVersionFieldNumber = 7,
    kSecretFieldNumber = 8,
    kAppIdFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kClientTypeFieldNumber = 3,
  };
  // required string client_name = 4;
  bool has_client_name() const;
  private:
  bool _internal_has_client_name() const;
  public:
  void clear_client_name();
  const std::string& client_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_name();
  PROTOBUF_NODISCARD std::string* release_client_name();
  void set_allocated_client_name(std::string* client_name);
  private:
  const std::string& _internal_client_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_name(const std::string& value);
  std::string* _internal_mutable_client_name();
  public:

  // required string os = 5;
  bool has_os() const;
  private:
  bool _internal_has_os() const;
  public:
  void clear_os();
  const std::string& os() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os();
  PROTOBUF_NODISCARD std::string* release_os();
  void set_allocated_os(std::string* os);
  private:
  const std::string& _internal_os() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os(const std::string& value);
  std::string* _internal_mutable_os();
  public:

  // required string device = 6;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const std::string& device() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* device);
  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(const std::string& value);
  std::string* _internal_mutable_device();
  public:

  // required string version = 7;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // required string secret = 8;
  bool has_secret() const;
  private:
  bool _internal_has_secret() const;
  public:
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 client_id = 2;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint32_t client_id() const;
  void set_client_id(uint32_t value);
  private:
  uint32_t _internal_client_id() const;
  void _internal_set_client_id(uint32_t value);
  public:

  // required uint32 client_type = 3;
  bool has_client_type() const;
  private:
  bool _internal_has_client_type() const;
  public:
  void clear_client_type();
  uint32_t client_type() const;
  void set_client_type(uint32_t value);
  private:
  uint32_t _internal_client_type() const;
  void _internal_set_client_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.RegisterReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
    uint32_t app_id_;
    uint32_t client_id_;
    uint32_t client_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_terminal_2eproto;
};
// -------------------------------------------------------------------

class RegisterRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.RegisterRsp) */ {
 public:
  inline RegisterRsp() : RegisterRsp(nullptr) {}
  ~RegisterRsp() override;
  explicit PROTOBUF_CONSTEXPR RegisterRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterRsp(const RegisterRsp& from);
  RegisterRsp(RegisterRsp&& from) noexcept
    : RegisterRsp() {
    *this = ::std::move(from);
  }

  inline RegisterRsp& operator=(const RegisterRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRsp& operator=(RegisterRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRsp* internal_default_instance() {
    return reinterpret_cast<const RegisterRsp*>(
               &_RegisterRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RegisterRsp& a, RegisterRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterRsp& from) {
    RegisterRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.RegisterRsp";
  }
  protected:
  explicit RegisterRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 5,
    kAppIdFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kRegisterIdFieldNumber = 3,
    kResultFieldNumber = 4,
  };
  // required string msg = 5;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 client_id = 2;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint32_t client_id() const;
  void set_client_id(uint32_t value);
  private:
  uint32_t _internal_client_id() const;
  void _internal_set_client_id(uint32_t value);
  public:

  // required uint32 register_id = 3;
  bool has_register_id() const;
  private:
  bool _internal_has_register_id() const;
  public:
  void clear_register_id();
  uint32_t register_id() const;
  void set_register_id(uint32_t value);
  private:
  uint32_t _internal_register_id() const;
  void _internal_set_register_id(uint32_t value);
  public:

  // required uint32 result = 4;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.RegisterRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    uint32_t app_id_;
    uint32_t client_id_;
    uint32_t register_id_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_terminal_2eproto;
};
// -------------------------------------------------------------------

class UnregisterReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.UnregisterReq) */ {
 public:
  inline UnregisterReq() : UnregisterReq(nullptr) {}
  ~UnregisterReq() override;
  explicit PROTOBUF_CONSTEXPR UnregisterReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnregisterReq(const UnregisterReq& from);
  UnregisterReq(UnregisterReq&& from) noexcept
    : UnregisterReq() {
    *this = ::std::move(from);
  }

  inline UnregisterReq& operator=(const UnregisterReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnregisterReq& operator=(UnregisterReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnregisterReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnregisterReq* internal_default_instance() {
    return reinterpret_cast<const UnregisterReq*>(
               &_UnregisterReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UnregisterReq& a, UnregisterReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UnregisterReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnregisterReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnregisterReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnregisterReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnregisterReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnregisterReq& from) {
    UnregisterReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnregisterReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.UnregisterReq";
  }
  protected:
  explicit UnregisterReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecretFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kRegisterIdFieldNumber = 3,
  };
  // required string secret = 4;
  bool has_secret() const;
  private:
  bool _internal_has_secret() const;
  public:
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 client_id = 2;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint32_t client_id() const;
  void set_client_id(uint32_t value);
  private:
  uint32_t _internal_client_id() const;
  void _internal_set_client_id(uint32_t value);
  public:

  // required uint32 register_id = 3;
  bool has_register_id() const;
  private:
  bool _internal_has_register_id() const;
  public:
  void clear_register_id();
  uint32_t register_id() const;
  void set_register_id(uint32_t value);
  private:
  uint32_t _internal_register_id() const;
  void _internal_set_register_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.UnregisterReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
    uint32_t app_id_;
    uint32_t client_id_;
    uint32_t register_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_terminal_2eproto;
};
// -------------------------------------------------------------------

class UnregisterRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.UnregisterRsp) */ {
 public:
  inline UnregisterRsp() : UnregisterRsp(nullptr) {}
  ~UnregisterRsp() override;
  explicit PROTOBUF_CONSTEXPR UnregisterRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnregisterRsp(const UnregisterRsp& from);
  UnregisterRsp(UnregisterRsp&& from) noexcept
    : UnregisterRsp() {
    *this = ::std::move(from);
  }

  inline UnregisterRsp& operator=(const UnregisterRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnregisterRsp& operator=(UnregisterRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnregisterRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnregisterRsp* internal_default_instance() {
    return reinterpret_cast<const UnregisterRsp*>(
               &_UnregisterRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UnregisterRsp& a, UnregisterRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(UnregisterRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnregisterRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnregisterRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnregisterRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnregisterRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnregisterRsp& from) {
    UnregisterRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnregisterRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.UnregisterRsp";
  }
  protected:
  explicit UnregisterRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 5,
    kAppIdFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kRegisterIdFieldNumber = 3,
    kResultFieldNumber = 4,
  };
  // required string msg = 5;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 client_id = 2;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint32_t client_id() const;
  void set_client_id(uint32_t value);
  private:
  uint32_t _internal_client_id() const;
  void _internal_set_client_id(uint32_t value);
  public:

  // required uint32 register_id = 3;
  bool has_register_id() const;
  private:
  bool _internal_has_register_id() const;
  public:
  void clear_register_id();
  uint32_t register_id() const;
  void set_register_id(uint32_t value);
  private:
  uint32_t _internal_register_id() const;
  void _internal_set_register_id(uint32_t value);
  public:

  // required uint32 result = 4;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.UnregisterRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    uint32_t app_id_;
    uint32_t client_id_;
    uint32_t register_id_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_terminal_2eproto;
};
// -------------------------------------------------------------------

class ClientOfflineReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.ClientOfflineReq) */ {
 public:
  inline ClientOfflineReq() : ClientOfflineReq(nullptr) {}
  ~ClientOfflineReq() override;
  explicit PROTOBUF_CONSTEXPR ClientOfflineReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientOfflineReq(const ClientOfflineReq& from);
  ClientOfflineReq(ClientOfflineReq&& from) noexcept
    : ClientOfflineReq() {
    *this = ::std::move(from);
  }

  inline ClientOfflineReq& operator=(const ClientOfflineReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientOfflineReq& operator=(ClientOfflineReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientOfflineReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientOfflineReq* internal_default_instance() {
    return reinterpret_cast<const ClientOfflineReq*>(
               &_ClientOfflineReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ClientOfflineReq& a, ClientOfflineReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientOfflineReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientOfflineReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientOfflineReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientOfflineReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientOfflineReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientOfflineReq& from) {
    ClientOfflineReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientOfflineReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.ClientOfflineReq";
  }
  protected:
  explicit ClientOfflineReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceIdFieldNumber = 2,
    kAppIdFieldNumber = 1,
    kClientIdFieldNumber = 3,
    kSessionIdFieldNumber = 4,
  };
  // required string instance_id = 2;
  bool has_instance_id() const;
  private:
  bool _internal_has_instance_id() const;
  public:
  void clear_instance_id();
  const std::string& instance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_id();
  PROTOBUF_NODISCARD std::string* release_instance_id();
  void set_allocated_instance_id(std::string* instance_id);
  private:
  const std::string& _internal_instance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_id(const std::string& value);
  std::string* _internal_mutable_instance_id();
  public:

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 client_id = 3;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint32_t client_id() const;
  void set_client_id(uint32_t value);
  private:
  uint32_t _internal_client_id() const;
  void _internal_set_client_id(uint32_t value);
  public:

  // required uint32 session_id = 4;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.ClientOfflineReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_id_;
    uint32_t app_id_;
    uint32_t client_id_;
    uint32_t session_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_terminal_2eproto;
};
// -------------------------------------------------------------------

class ClientOfflineRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.ClientOfflineRsp) */ {
 public:
  inline ClientOfflineRsp() : ClientOfflineRsp(nullptr) {}
  ~ClientOfflineRsp() override;
  explicit PROTOBUF_CONSTEXPR ClientOfflineRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientOfflineRsp(const ClientOfflineRsp& from);
  ClientOfflineRsp(ClientOfflineRsp&& from) noexcept
    : ClientOfflineRsp() {
    *this = ::std::move(from);
  }

  inline ClientOfflineRsp& operator=(const ClientOfflineRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientOfflineRsp& operator=(ClientOfflineRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientOfflineRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientOfflineRsp* internal_default_instance() {
    return reinterpret_cast<const ClientOfflineRsp*>(
               &_ClientOfflineRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ClientOfflineRsp& a, ClientOfflineRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientOfflineRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientOfflineRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientOfflineRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientOfflineRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientOfflineRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientOfflineRsp& from) {
    ClientOfflineRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientOfflineRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.ClientOfflineRsp";
  }
  protected:
  explicit ClientOfflineRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceIdFieldNumber = 2,
    kAppIdFieldNumber = 1,
    kClientIdFieldNumber = 3,
    kSessionIdFieldNumber = 4,
  };
  // required string instance_id = 2;
  bool has_instance_id() const;
  private:
  bool _internal_has_instance_id() const;
  public:
  void clear_instance_id();
  const std::string& instance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_id();
  PROTOBUF_NODISCARD std::string* release_instance_id();
  void set_allocated_instance_id(std::string* instance_id);
  private:
  const std::string& _internal_instance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_id(const std::string& value);
  std::string* _internal_mutable_instance_id();
  public:

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 client_id = 3;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint32_t client_id() const;
  void set_client_id(uint32_t value);
  private:
  uint32_t _internal_client_id() const;
  void _internal_set_client_id(uint32_t value);
  public:

  // required uint32 session_id = 4;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.ClientOfflineRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_id_;
    uint32_t app_id_;
    uint32_t client_id_;
    uint32_t session_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_terminal_2eproto;
};
// -------------------------------------------------------------------

class ClientOfflineNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.ClientOfflineNotify) */ {
 public:
  inline ClientOfflineNotify() : ClientOfflineNotify(nullptr) {}
  ~ClientOfflineNotify() override;
  explicit PROTOBUF_CONSTEXPR ClientOfflineNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientOfflineNotify(const ClientOfflineNotify& from);
  ClientOfflineNotify(ClientOfflineNotify&& from) noexcept
    : ClientOfflineNotify() {
    *this = ::std::move(from);
  }

  inline ClientOfflineNotify& operator=(const ClientOfflineNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientOfflineNotify& operator=(ClientOfflineNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientOfflineNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientOfflineNotify* internal_default_instance() {
    return reinterpret_cast<const ClientOfflineNotify*>(
               &_ClientOfflineNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ClientOfflineNotify& a, ClientOfflineNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientOfflineNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientOfflineNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientOfflineNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientOfflineNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientOfflineNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientOfflineNotify& from) {
    ClientOfflineNotify::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientOfflineNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.ClientOfflineNotify";
  }
  protected:
  explicit ClientOfflineNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kRegisterIdFieldNumber = 3,
  };
  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 client_id = 2;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint32_t client_id() const;
  void set_client_id(uint32_t value);
  private:
  uint32_t _internal_client_id() const;
  void _internal_set_client_id(uint32_t value);
  public:

  // required uint32 register_id = 3;
  bool has_register_id() const;
  private:
  bool _internal_has_register_id() const;
  public:
  void clear_register_id();
  uint32_t register_id() const;
  void set_register_id(uint32_t value);
  private:
  uint32_t _internal_register_id() const;
  void _internal_set_register_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.ClientOfflineNotify)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t app_id_;
    uint32_t client_id_;
    uint32_t register_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_terminal_2eproto;
};
// -------------------------------------------------------------------

class RegisterReqExtendData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.RegisterReqExtendData) */ {
 public:
  inline RegisterReqExtendData() : RegisterReqExtendData(nullptr) {}
  ~RegisterReqExtendData() override;
  explicit PROTOBUF_CONSTEXPR RegisterReqExtendData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterReqExtendData(const RegisterReqExtendData& from);
  RegisterReqExtendData(RegisterReqExtendData&& from) noexcept
    : RegisterReqExtendData() {
    *this = ::std::move(from);
  }

  inline RegisterReqExtendData& operator=(const RegisterReqExtendData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterReqExtendData& operator=(RegisterReqExtendData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterReqExtendData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterReqExtendData* internal_default_instance() {
    return reinterpret_cast<const RegisterReqExtendData*>(
               &_RegisterReqExtendData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RegisterReqExtendData& a, RegisterReqExtendData& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterReqExtendData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterReqExtendData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterReqExtendData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterReqExtendData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterReqExtendData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterReqExtendData& from) {
    RegisterReqExtendData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterReqExtendData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.RegisterReqExtendData";
  }
  protected:
  explicit RegisterReqExtendData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceIdFieldNumber = 1,
    kSessionIdFieldNumber = 2,
  };
  // required string instance_id = 1;
  bool has_instance_id() const;
  private:
  bool _internal_has_instance_id() const;
  public:
  void clear_instance_id();
  const std::string& instance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_id();
  PROTOBUF_NODISCARD std::string* release_instance_id();
  void set_allocated_instance_id(std::string* instance_id);
  private:
  const std::string& _internal_instance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_id(const std::string& value);
  std::string* _internal_mutable_instance_id();
  public:

  // required uint32 session_id = 2;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.RegisterReqExtendData)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_id_;
    uint32_t session_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_terminal_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RegisterReq

// required uint32 app_id = 1;
inline bool RegisterReq::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RegisterReq::has_app_id() const {
  return _internal_has_app_id();
}
inline void RegisterReq::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t RegisterReq::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t RegisterReq::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.RegisterReq.app_id)
  return _internal_app_id();
}
inline void RegisterReq::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.app_id_ = value;
}
inline void RegisterReq::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.RegisterReq.app_id)
}

// required uint32 client_id = 2;
inline bool RegisterReq::_internal_has_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RegisterReq::has_client_id() const {
  return _internal_has_client_id();
}
inline void RegisterReq::clear_client_id() {
  _impl_.client_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t RegisterReq::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint32_t RegisterReq::client_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.RegisterReq.client_id)
  return _internal_client_id();
}
inline void RegisterReq::_internal_set_client_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.client_id_ = value;
}
inline void RegisterReq::set_client_id(uint32_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.RegisterReq.client_id)
}

// required uint32 client_type = 3;
inline bool RegisterReq::_internal_has_client_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool RegisterReq::has_client_type() const {
  return _internal_has_client_type();
}
inline void RegisterReq::clear_client_type() {
  _impl_.client_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t RegisterReq::_internal_client_type() const {
  return _impl_.client_type_;
}
inline uint32_t RegisterReq::client_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.RegisterReq.client_type)
  return _internal_client_type();
}
inline void RegisterReq::_internal_set_client_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.client_type_ = value;
}
inline void RegisterReq::set_client_type(uint32_t value) {
  _internal_set_client_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.RegisterReq.client_type)
}

// required string client_name = 4;
inline bool RegisterReq::_internal_has_client_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegisterReq::has_client_name() const {
  return _internal_has_client_name();
}
inline void RegisterReq::clear_client_name() {
  _impl_.client_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegisterReq::client_name() const {
  // @@protoc_insertion_point(field_get:jukey.prot.RegisterReq.client_name)
  return _internal_client_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterReq::set_client_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.client_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.RegisterReq.client_name)
}
inline std::string* RegisterReq::mutable_client_name() {
  std::string* _s = _internal_mutable_client_name();
  // @@protoc_insertion_point(field_mutable:jukey.prot.RegisterReq.client_name)
  return _s;
}
inline const std::string& RegisterReq::_internal_client_name() const {
  return _impl_.client_name_.Get();
}
inline void RegisterReq::_internal_set_client_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.client_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterReq::_internal_mutable_client_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.client_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterReq::release_client_name() {
  // @@protoc_insertion_point(field_release:jukey.prot.RegisterReq.client_name)
  if (!_internal_has_client_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.client_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_name_.IsDefault()) {
    _impl_.client_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RegisterReq::set_allocated_client_name(std::string* client_name) {
  if (client_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.client_name_.SetAllocated(client_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_name_.IsDefault()) {
    _impl_.client_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.RegisterReq.client_name)
}

// required string os = 5;
inline bool RegisterReq::_internal_has_os() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegisterReq::has_os() const {
  return _internal_has_os();
}
inline void RegisterReq::clear_os() {
  _impl_.os_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RegisterReq::os() const {
  // @@protoc_insertion_point(field_get:jukey.prot.RegisterReq.os)
  return _internal_os();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterReq::set_os(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.os_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.RegisterReq.os)
}
inline std::string* RegisterReq::mutable_os() {
  std::string* _s = _internal_mutable_os();
  // @@protoc_insertion_point(field_mutable:jukey.prot.RegisterReq.os)
  return _s;
}
inline const std::string& RegisterReq::_internal_os() const {
  return _impl_.os_.Get();
}
inline void RegisterReq::_internal_set_os(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.os_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterReq::_internal_mutable_os() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.os_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterReq::release_os() {
  // @@protoc_insertion_point(field_release:jukey.prot.RegisterReq.os)
  if (!_internal_has_os()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.os_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_.IsDefault()) {
    _impl_.os_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RegisterReq::set_allocated_os(std::string* os) {
  if (os != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.os_.SetAllocated(os, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_.IsDefault()) {
    _impl_.os_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.RegisterReq.os)
}

// required string device = 6;
inline bool RegisterReq::_internal_has_device() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegisterReq::has_device() const {
  return _internal_has_device();
}
inline void RegisterReq::clear_device() {
  _impl_.device_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RegisterReq::device() const {
  // @@protoc_insertion_point(field_get:jukey.prot.RegisterReq.device)
  return _internal_device();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterReq::set_device(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.device_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.RegisterReq.device)
}
inline std::string* RegisterReq::mutable_device() {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:jukey.prot.RegisterReq.device)
  return _s;
}
inline const std::string& RegisterReq::_internal_device() const {
  return _impl_.device_.Get();
}
inline void RegisterReq::_internal_set_device(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.device_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterReq::_internal_mutable_device() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.device_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterReq::release_device() {
  // @@protoc_insertion_point(field_release:jukey.prot.RegisterReq.device)
  if (!_internal_has_device()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.device_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_.IsDefault()) {
    _impl_.device_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RegisterReq::set_allocated_device(std::string* device) {
  if (device != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.device_.SetAllocated(device, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_.IsDefault()) {
    _impl_.device_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.RegisterReq.device)
}

// required string version = 7;
inline bool RegisterReq::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RegisterReq::has_version() const {
  return _internal_has_version();
}
inline void RegisterReq::clear_version() {
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RegisterReq::version() const {
  // @@protoc_insertion_point(field_get:jukey.prot.RegisterReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterReq::set_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.RegisterReq.version)
}
inline std::string* RegisterReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:jukey.prot.RegisterReq.version)
  return _s;
}
inline const std::string& RegisterReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void RegisterReq::_internal_set_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterReq::_internal_mutable_version() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterReq::release_version() {
  // @@protoc_insertion_point(field_release:jukey.prot.RegisterReq.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RegisterReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.RegisterReq.version)
}

// required string secret = 8;
inline bool RegisterReq::_internal_has_secret() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RegisterReq::has_secret() const {
  return _internal_has_secret();
}
inline void RegisterReq::clear_secret() {
  _impl_.secret_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& RegisterReq::secret() const {
  // @@protoc_insertion_point(field_get:jukey.prot.RegisterReq.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterReq::set_secret(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.RegisterReq.secret)
}
inline std::string* RegisterReq::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:jukey.prot.RegisterReq.secret)
  return _s;
}
inline const std::string& RegisterReq::_internal_secret() const {
  return _impl_.secret_.Get();
}
inline void RegisterReq::_internal_set_secret(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.secret_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterReq::_internal_mutable_secret() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.secret_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterReq::release_secret() {
  // @@protoc_insertion_point(field_release:jukey.prot.RegisterReq.secret)
  if (!_internal_has_secret()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.secret_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.secret_.IsDefault()) {
    _impl_.secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RegisterReq::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.secret_.IsDefault()) {
    _impl_.secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.RegisterReq.secret)
}

// -------------------------------------------------------------------

// RegisterRsp

// required uint32 app_id = 1;
inline bool RegisterRsp::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegisterRsp::has_app_id() const {
  return _internal_has_app_id();
}
inline void RegisterRsp::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RegisterRsp::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t RegisterRsp::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.RegisterRsp.app_id)
  return _internal_app_id();
}
inline void RegisterRsp::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_id_ = value;
}
inline void RegisterRsp::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.RegisterRsp.app_id)
}

// required uint32 client_id = 2;
inline bool RegisterRsp::_internal_has_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegisterRsp::has_client_id() const {
  return _internal_has_client_id();
}
inline void RegisterRsp::clear_client_id() {
  _impl_.client_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t RegisterRsp::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint32_t RegisterRsp::client_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.RegisterRsp.client_id)
  return _internal_client_id();
}
inline void RegisterRsp::_internal_set_client_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.client_id_ = value;
}
inline void RegisterRsp::set_client_id(uint32_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.RegisterRsp.client_id)
}

// required uint32 register_id = 3;
inline bool RegisterRsp::_internal_has_register_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RegisterRsp::has_register_id() const {
  return _internal_has_register_id();
}
inline void RegisterRsp::clear_register_id() {
  _impl_.register_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t RegisterRsp::_internal_register_id() const {
  return _impl_.register_id_;
}
inline uint32_t RegisterRsp::register_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.RegisterRsp.register_id)
  return _internal_register_id();
}
inline void RegisterRsp::_internal_set_register_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.register_id_ = value;
}
inline void RegisterRsp::set_register_id(uint32_t value) {
  _internal_set_register_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.RegisterRsp.register_id)
}

// required uint32 result = 4;
inline bool RegisterRsp::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RegisterRsp::has_result() const {
  return _internal_has_result();
}
inline void RegisterRsp::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t RegisterRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t RegisterRsp::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.RegisterRsp.result)
  return _internal_result();
}
inline void RegisterRsp::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.result_ = value;
}
inline void RegisterRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.RegisterRsp.result)
}

// required string msg = 5;
inline bool RegisterRsp::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegisterRsp::has_msg() const {
  return _internal_has_msg();
}
inline void RegisterRsp::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegisterRsp::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.RegisterRsp.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRsp::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.RegisterRsp.msg)
}
inline std::string* RegisterRsp::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.RegisterRsp.msg)
  return _s;
}
inline const std::string& RegisterRsp::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void RegisterRsp::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRsp::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRsp::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.RegisterRsp.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RegisterRsp::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.RegisterRsp.msg)
}

// -------------------------------------------------------------------

// UnregisterReq

// required uint32 app_id = 1;
inline bool UnregisterReq::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UnregisterReq::has_app_id() const {
  return _internal_has_app_id();
}
inline void UnregisterReq::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t UnregisterReq::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t UnregisterReq::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnregisterReq.app_id)
  return _internal_app_id();
}
inline void UnregisterReq::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_id_ = value;
}
inline void UnregisterReq::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnregisterReq.app_id)
}

// required uint32 client_id = 2;
inline bool UnregisterReq::_internal_has_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UnregisterReq::has_client_id() const {
  return _internal_has_client_id();
}
inline void UnregisterReq::clear_client_id() {
  _impl_.client_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UnregisterReq::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint32_t UnregisterReq::client_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnregisterReq.client_id)
  return _internal_client_id();
}
inline void UnregisterReq::_internal_set_client_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.client_id_ = value;
}
inline void UnregisterReq::set_client_id(uint32_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnregisterReq.client_id)
}

// required uint32 register_id = 3;
inline bool UnregisterReq::_internal_has_register_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UnregisterReq::has_register_id() const {
  return _internal_has_register_id();
}
inline void UnregisterReq::clear_register_id() {
  _impl_.register_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t UnregisterReq::_internal_register_id() const {
  return _impl_.register_id_;
}
inline uint32_t UnregisterReq::register_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnregisterReq.register_id)
  return _internal_register_id();
}
inline void UnregisterReq::_internal_set_register_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.register_id_ = value;
}
inline void UnregisterReq::set_register_id(uint32_t value) {
  _internal_set_register_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnregisterReq.register_id)
}

// required string secret = 4;
inline bool UnregisterReq::_internal_has_secret() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnregisterReq::has_secret() const {
  return _internal_has_secret();
}
inline void UnregisterReq::clear_secret() {
  _impl_.secret_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnregisterReq::secret() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnregisterReq.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnregisterReq::set_secret(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.UnregisterReq.secret)
}
inline std::string* UnregisterReq::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:jukey.prot.UnregisterReq.secret)
  return _s;
}
inline const std::string& UnregisterReq::_internal_secret() const {
  return _impl_.secret_.Get();
}
inline void UnregisterReq::_internal_set_secret(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.secret_.Set(value, GetArenaForAllocation());
}
inline std::string* UnregisterReq::_internal_mutable_secret() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.secret_.Mutable(GetArenaForAllocation());
}
inline std::string* UnregisterReq::release_secret() {
  // @@protoc_insertion_point(field_release:jukey.prot.UnregisterReq.secret)
  if (!_internal_has_secret()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.secret_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.secret_.IsDefault()) {
    _impl_.secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UnregisterReq::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.secret_.IsDefault()) {
    _impl_.secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.UnregisterReq.secret)
}

// -------------------------------------------------------------------

// UnregisterRsp

// required uint32 app_id = 1;
inline bool UnregisterRsp::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UnregisterRsp::has_app_id() const {
  return _internal_has_app_id();
}
inline void UnregisterRsp::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t UnregisterRsp::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t UnregisterRsp::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnregisterRsp.app_id)
  return _internal_app_id();
}
inline void UnregisterRsp::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_id_ = value;
}
inline void UnregisterRsp::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnregisterRsp.app_id)
}

// required uint32 client_id = 2;
inline bool UnregisterRsp::_internal_has_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UnregisterRsp::has_client_id() const {
  return _internal_has_client_id();
}
inline void UnregisterRsp::clear_client_id() {
  _impl_.client_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UnregisterRsp::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint32_t UnregisterRsp::client_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnregisterRsp.client_id)
  return _internal_client_id();
}
inline void UnregisterRsp::_internal_set_client_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.client_id_ = value;
}
inline void UnregisterRsp::set_client_id(uint32_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnregisterRsp.client_id)
}

// required uint32 register_id = 3;
inline bool UnregisterRsp::_internal_has_register_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UnregisterRsp::has_register_id() const {
  return _internal_has_register_id();
}
inline void UnregisterRsp::clear_register_id() {
  _impl_.register_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t UnregisterRsp::_internal_register_id() const {
  return _impl_.register_id_;
}
inline uint32_t UnregisterRsp::register_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnregisterRsp.register_id)
  return _internal_register_id();
}
inline void UnregisterRsp::_internal_set_register_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.register_id_ = value;
}
inline void UnregisterRsp::set_register_id(uint32_t value) {
  _internal_set_register_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnregisterRsp.register_id)
}

// required uint32 result = 4;
inline bool UnregisterRsp::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UnregisterRsp::has_result() const {
  return _internal_has_result();
}
inline void UnregisterRsp::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t UnregisterRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t UnregisterRsp::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnregisterRsp.result)
  return _internal_result();
}
inline void UnregisterRsp::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.result_ = value;
}
inline void UnregisterRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnregisterRsp.result)
}

// required string msg = 5;
inline bool UnregisterRsp::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnregisterRsp::has_msg() const {
  return _internal_has_msg();
}
inline void UnregisterRsp::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnregisterRsp::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnregisterRsp.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnregisterRsp::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.UnregisterRsp.msg)
}
inline std::string* UnregisterRsp::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.UnregisterRsp.msg)
  return _s;
}
inline const std::string& UnregisterRsp::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void UnregisterRsp::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* UnregisterRsp::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* UnregisterRsp::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.UnregisterRsp.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UnregisterRsp::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.UnregisterRsp.msg)
}

// -------------------------------------------------------------------

// ClientOfflineReq

// required uint32 app_id = 1;
inline bool ClientOfflineReq::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientOfflineReq::has_app_id() const {
  return _internal_has_app_id();
}
inline void ClientOfflineReq::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ClientOfflineReq::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t ClientOfflineReq::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.ClientOfflineReq.app_id)
  return _internal_app_id();
}
inline void ClientOfflineReq::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_id_ = value;
}
inline void ClientOfflineReq::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.ClientOfflineReq.app_id)
}

// required string instance_id = 2;
inline bool ClientOfflineReq::_internal_has_instance_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientOfflineReq::has_instance_id() const {
  return _internal_has_instance_id();
}
inline void ClientOfflineReq::clear_instance_id() {
  _impl_.instance_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientOfflineReq::instance_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.ClientOfflineReq.instance_id)
  return _internal_instance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientOfflineReq::set_instance_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.instance_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.ClientOfflineReq.instance_id)
}
inline std::string* ClientOfflineReq::mutable_instance_id() {
  std::string* _s = _internal_mutable_instance_id();
  // @@protoc_insertion_point(field_mutable:jukey.prot.ClientOfflineReq.instance_id)
  return _s;
}
inline const std::string& ClientOfflineReq::_internal_instance_id() const {
  return _impl_.instance_id_.Get();
}
inline void ClientOfflineReq::_internal_set_instance_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.instance_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientOfflineReq::_internal_mutable_instance_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.instance_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientOfflineReq::release_instance_id() {
  // @@protoc_insertion_point(field_release:jukey.prot.ClientOfflineReq.instance_id)
  if (!_internal_has_instance_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.instance_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientOfflineReq::set_allocated_instance_id(std::string* instance_id) {
  if (instance_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.instance_id_.SetAllocated(instance_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.ClientOfflineReq.instance_id)
}

// required uint32 client_id = 3;
inline bool ClientOfflineReq::_internal_has_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ClientOfflineReq::has_client_id() const {
  return _internal_has_client_id();
}
inline void ClientOfflineReq::clear_client_id() {
  _impl_.client_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ClientOfflineReq::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint32_t ClientOfflineReq::client_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.ClientOfflineReq.client_id)
  return _internal_client_id();
}
inline void ClientOfflineReq::_internal_set_client_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.client_id_ = value;
}
inline void ClientOfflineReq::set_client_id(uint32_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.ClientOfflineReq.client_id)
}

// required uint32 session_id = 4;
inline bool ClientOfflineReq::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ClientOfflineReq::has_session_id() const {
  return _internal_has_session_id();
}
inline void ClientOfflineReq::clear_session_id() {
  _impl_.session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ClientOfflineReq::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t ClientOfflineReq::session_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.ClientOfflineReq.session_id)
  return _internal_session_id();
}
inline void ClientOfflineReq::_internal_set_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.session_id_ = value;
}
inline void ClientOfflineReq::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.ClientOfflineReq.session_id)
}

// -------------------------------------------------------------------

// ClientOfflineRsp

// required uint32 app_id = 1;
inline bool ClientOfflineRsp::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientOfflineRsp::has_app_id() const {
  return _internal_has_app_id();
}
inline void ClientOfflineRsp::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ClientOfflineRsp::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t ClientOfflineRsp::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.ClientOfflineRsp.app_id)
  return _internal_app_id();
}
inline void ClientOfflineRsp::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_id_ = value;
}
inline void ClientOfflineRsp::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.ClientOfflineRsp.app_id)
}

// required string instance_id = 2;
inline bool ClientOfflineRsp::_internal_has_instance_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientOfflineRsp::has_instance_id() const {
  return _internal_has_instance_id();
}
inline void ClientOfflineRsp::clear_instance_id() {
  _impl_.instance_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientOfflineRsp::instance_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.ClientOfflineRsp.instance_id)
  return _internal_instance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientOfflineRsp::set_instance_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.instance_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.ClientOfflineRsp.instance_id)
}
inline std::string* ClientOfflineRsp::mutable_instance_id() {
  std::string* _s = _internal_mutable_instance_id();
  // @@protoc_insertion_point(field_mutable:jukey.prot.ClientOfflineRsp.instance_id)
  return _s;
}
inline const std::string& ClientOfflineRsp::_internal_instance_id() const {
  return _impl_.instance_id_.Get();
}
inline void ClientOfflineRsp::_internal_set_instance_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.instance_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientOfflineRsp::_internal_mutable_instance_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.instance_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientOfflineRsp::release_instance_id() {
  // @@protoc_insertion_point(field_release:jukey.prot.ClientOfflineRsp.instance_id)
  if (!_internal_has_instance_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.instance_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientOfflineRsp::set_allocated_instance_id(std::string* instance_id) {
  if (instance_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.instance_id_.SetAllocated(instance_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.ClientOfflineRsp.instance_id)
}

// required uint32 client_id = 3;
inline bool ClientOfflineRsp::_internal_has_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ClientOfflineRsp::has_client_id() const {
  return _internal_has_client_id();
}
inline void ClientOfflineRsp::clear_client_id() {
  _impl_.client_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ClientOfflineRsp::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint32_t ClientOfflineRsp::client_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.ClientOfflineRsp.client_id)
  return _internal_client_id();
}
inline void ClientOfflineRsp::_internal_set_client_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.client_id_ = value;
}
inline void ClientOfflineRsp::set_client_id(uint32_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.ClientOfflineRsp.client_id)
}

// required uint32 session_id = 4;
inline bool ClientOfflineRsp::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ClientOfflineRsp::has_session_id() const {
  return _internal_has_session_id();
}
inline void ClientOfflineRsp::clear_session_id() {
  _impl_.session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ClientOfflineRsp::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t ClientOfflineRsp::session_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.ClientOfflineRsp.session_id)
  return _internal_session_id();
}
inline void ClientOfflineRsp::_internal_set_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.session_id_ = value;
}
inline void ClientOfflineRsp::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.ClientOfflineRsp.session_id)
}

// -------------------------------------------------------------------

// ClientOfflineNotify

// required uint32 app_id = 1;
inline bool ClientOfflineNotify::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientOfflineNotify::has_app_id() const {
  return _internal_has_app_id();
}
inline void ClientOfflineNotify::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ClientOfflineNotify::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t ClientOfflineNotify::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.ClientOfflineNotify.app_id)
  return _internal_app_id();
}
inline void ClientOfflineNotify::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_id_ = value;
}
inline void ClientOfflineNotify::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.ClientOfflineNotify.app_id)
}

// required uint32 client_id = 2;
inline bool ClientOfflineNotify::_internal_has_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientOfflineNotify::has_client_id() const {
  return _internal_has_client_id();
}
inline void ClientOfflineNotify::clear_client_id() {
  _impl_.client_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ClientOfflineNotify::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint32_t ClientOfflineNotify::client_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.ClientOfflineNotify.client_id)
  return _internal_client_id();
}
inline void ClientOfflineNotify::_internal_set_client_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.client_id_ = value;
}
inline void ClientOfflineNotify::set_client_id(uint32_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.ClientOfflineNotify.client_id)
}

// required uint32 register_id = 3;
inline bool ClientOfflineNotify::_internal_has_register_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ClientOfflineNotify::has_register_id() const {
  return _internal_has_register_id();
}
inline void ClientOfflineNotify::clear_register_id() {
  _impl_.register_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ClientOfflineNotify::_internal_register_id() const {
  return _impl_.register_id_;
}
inline uint32_t ClientOfflineNotify::register_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.ClientOfflineNotify.register_id)
  return _internal_register_id();
}
inline void ClientOfflineNotify::_internal_set_register_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.register_id_ = value;
}
inline void ClientOfflineNotify::set_register_id(uint32_t value) {
  _internal_set_register_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.ClientOfflineNotify.register_id)
}

// -------------------------------------------------------------------

// RegisterReqExtendData

// required string instance_id = 1;
inline bool RegisterReqExtendData::_internal_has_instance_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegisterReqExtendData::has_instance_id() const {
  return _internal_has_instance_id();
}
inline void RegisterReqExtendData::clear_instance_id() {
  _impl_.instance_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegisterReqExtendData::instance_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.RegisterReqExtendData.instance_id)
  return _internal_instance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterReqExtendData::set_instance_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.instance_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.RegisterReqExtendData.instance_id)
}
inline std::string* RegisterReqExtendData::mutable_instance_id() {
  std::string* _s = _internal_mutable_instance_id();
  // @@protoc_insertion_point(field_mutable:jukey.prot.RegisterReqExtendData.instance_id)
  return _s;
}
inline const std::string& RegisterReqExtendData::_internal_instance_id() const {
  return _impl_.instance_id_.Get();
}
inline void RegisterReqExtendData::_internal_set_instance_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.instance_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterReqExtendData::_internal_mutable_instance_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.instance_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterReqExtendData::release_instance_id() {
  // @@protoc_insertion_point(field_release:jukey.prot.RegisterReqExtendData.instance_id)
  if (!_internal_has_instance_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.instance_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RegisterReqExtendData::set_allocated_instance_id(std::string* instance_id) {
  if (instance_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.instance_id_.SetAllocated(instance_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.RegisterReqExtendData.instance_id)
}

// required uint32 session_id = 2;
inline bool RegisterReqExtendData::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegisterReqExtendData::has_session_id() const {
  return _internal_has_session_id();
}
inline void RegisterReqExtendData::clear_session_id() {
  _impl_.session_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RegisterReqExtendData::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint32_t RegisterReqExtendData::session_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.RegisterReqExtendData.session_id)
  return _internal_session_id();
}
inline void RegisterReqExtendData::_internal_set_session_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.session_id_ = value;
}
inline void RegisterReqExtendData::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.RegisterReqExtendData.session_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace prot
}  // namespace jukey

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_terminal_2eproto
