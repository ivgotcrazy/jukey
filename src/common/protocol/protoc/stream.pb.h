// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stream.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_stream_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_stream_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_stream_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_stream_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_stream_2eproto;
namespace jukey {
namespace prot {
class GetParentNodeReq;
struct GetParentNodeReqDefaultTypeInternal;
extern GetParentNodeReqDefaultTypeInternal _GetParentNodeReq_default_instance_;
class GetParentNodeRsp;
struct GetParentNodeRspDefaultTypeInternal;
extern GetParentNodeRspDefaultTypeInternal _GetParentNodeRsp_default_instance_;
class LoginSendChannelAck;
struct LoginSendChannelAckDefaultTypeInternal;
extern LoginSendChannelAckDefaultTypeInternal _LoginSendChannelAck_default_instance_;
class LoginSendChannelNotify;
struct LoginSendChannelNotifyDefaultTypeInternal;
extern LoginSendChannelNotifyDefaultTypeInternal _LoginSendChannelNotify_default_instance_;
class PublishStreamReq;
struct PublishStreamReqDefaultTypeInternal;
extern PublishStreamReqDefaultTypeInternal _PublishStreamReq_default_instance_;
class PublishStreamRsp;
struct PublishStreamRspDefaultTypeInternal;
extern PublishStreamRspDefaultTypeInternal _PublishStreamRsp_default_instance_;
class StreamNode;
struct StreamNodeDefaultTypeInternal;
extern StreamNodeDefaultTypeInternal _StreamNode_default_instance_;
class SubscribeStreamReq;
struct SubscribeStreamReqDefaultTypeInternal;
extern SubscribeStreamReqDefaultTypeInternal _SubscribeStreamReq_default_instance_;
class SubscribeStreamRsp;
struct SubscribeStreamRspDefaultTypeInternal;
extern SubscribeStreamRspDefaultTypeInternal _SubscribeStreamRsp_default_instance_;
class UnpublishStreamReq;
struct UnpublishStreamReqDefaultTypeInternal;
extern UnpublishStreamReqDefaultTypeInternal _UnpublishStreamReq_default_instance_;
class UnpublishStreamRsp;
struct UnpublishStreamRspDefaultTypeInternal;
extern UnpublishStreamRspDefaultTypeInternal _UnpublishStreamRsp_default_instance_;
class UnsubscribeStreamReq;
struct UnsubscribeStreamReqDefaultTypeInternal;
extern UnsubscribeStreamReqDefaultTypeInternal _UnsubscribeStreamReq_default_instance_;
class UnsubscribeStreamRsp;
struct UnsubscribeStreamRspDefaultTypeInternal;
extern UnsubscribeStreamRspDefaultTypeInternal _UnsubscribeStreamRsp_default_instance_;
}  // namespace prot
}  // namespace jukey
PROTOBUF_NAMESPACE_OPEN
template<> ::jukey::prot::GetParentNodeReq* Arena::CreateMaybeMessage<::jukey::prot::GetParentNodeReq>(Arena*);
template<> ::jukey::prot::GetParentNodeRsp* Arena::CreateMaybeMessage<::jukey::prot::GetParentNodeRsp>(Arena*);
template<> ::jukey::prot::LoginSendChannelAck* Arena::CreateMaybeMessage<::jukey::prot::LoginSendChannelAck>(Arena*);
template<> ::jukey::prot::LoginSendChannelNotify* Arena::CreateMaybeMessage<::jukey::prot::LoginSendChannelNotify>(Arena*);
template<> ::jukey::prot::PublishStreamReq* Arena::CreateMaybeMessage<::jukey::prot::PublishStreamReq>(Arena*);
template<> ::jukey::prot::PublishStreamRsp* Arena::CreateMaybeMessage<::jukey::prot::PublishStreamRsp>(Arena*);
template<> ::jukey::prot::StreamNode* Arena::CreateMaybeMessage<::jukey::prot::StreamNode>(Arena*);
template<> ::jukey::prot::SubscribeStreamReq* Arena::CreateMaybeMessage<::jukey::prot::SubscribeStreamReq>(Arena*);
template<> ::jukey::prot::SubscribeStreamRsp* Arena::CreateMaybeMessage<::jukey::prot::SubscribeStreamRsp>(Arena*);
template<> ::jukey::prot::UnpublishStreamReq* Arena::CreateMaybeMessage<::jukey::prot::UnpublishStreamReq>(Arena*);
template<> ::jukey::prot::UnpublishStreamRsp* Arena::CreateMaybeMessage<::jukey::prot::UnpublishStreamRsp>(Arena*);
template<> ::jukey::prot::UnsubscribeStreamReq* Arena::CreateMaybeMessage<::jukey::prot::UnsubscribeStreamReq>(Arena*);
template<> ::jukey::prot::UnsubscribeStreamRsp* Arena::CreateMaybeMessage<::jukey::prot::UnsubscribeStreamRsp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace jukey {
namespace prot {

// ===================================================================

class PublishStreamReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.PublishStreamReq) */ {
 public:
  inline PublishStreamReq() : PublishStreamReq(nullptr) {}
  ~PublishStreamReq() override;
  explicit PROTOBUF_CONSTEXPR PublishStreamReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishStreamReq(const PublishStreamReq& from);
  PublishStreamReq(PublishStreamReq&& from) noexcept
    : PublishStreamReq() {
    *this = ::std::move(from);
  }

  inline PublishStreamReq& operator=(const PublishStreamReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishStreamReq& operator=(PublishStreamReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishStreamReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishStreamReq* internal_default_instance() {
    return reinterpret_cast<const PublishStreamReq*>(
               &_PublishStreamReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PublishStreamReq& a, PublishStreamReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishStreamReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishStreamReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishStreamReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishStreamReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishStreamReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishStreamReq& from) {
    PublishStreamReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishStreamReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.PublishStreamReq";
  }
  protected:
  explicit PublishStreamReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 5,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kUserIdFieldNumber = 3,
  };
  // required string token = 5;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.PublishStreamReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_type_;
    uint32_t user_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class PublishStreamRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.PublishStreamRsp) */ {
 public:
  inline PublishStreamRsp() : PublishStreamRsp(nullptr) {}
  ~PublishStreamRsp() override;
  explicit PROTOBUF_CONSTEXPR PublishStreamRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishStreamRsp(const PublishStreamRsp& from);
  PublishStreamRsp(PublishStreamRsp&& from) noexcept
    : PublishStreamRsp() {
    *this = ::std::move(from);
  }

  inline PublishStreamRsp& operator=(const PublishStreamRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishStreamRsp& operator=(PublishStreamRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishStreamRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishStreamRsp* internal_default_instance() {
    return reinterpret_cast<const PublishStreamRsp*>(
               &_PublishStreamRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PublishStreamRsp& a, PublishStreamRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishStreamRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishStreamRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishStreamRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishStreamRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishStreamRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishStreamRsp& from) {
    PublishStreamRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishStreamRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.PublishStreamRsp";
  }
  protected:
  explicit PublishStreamRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 6,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kResultFieldNumber = 5,
  };
  // required string msg = 6;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 result = 5;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.PublishStreamRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_type_;
    uint32_t user_id_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class UnpublishStreamReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.UnpublishStreamReq) */ {
 public:
  inline UnpublishStreamReq() : UnpublishStreamReq(nullptr) {}
  ~UnpublishStreamReq() override;
  explicit PROTOBUF_CONSTEXPR UnpublishStreamReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnpublishStreamReq(const UnpublishStreamReq& from);
  UnpublishStreamReq(UnpublishStreamReq&& from) noexcept
    : UnpublishStreamReq() {
    *this = ::std::move(from);
  }

  inline UnpublishStreamReq& operator=(const UnpublishStreamReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnpublishStreamReq& operator=(UnpublishStreamReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnpublishStreamReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnpublishStreamReq* internal_default_instance() {
    return reinterpret_cast<const UnpublishStreamReq*>(
               &_UnpublishStreamReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UnpublishStreamReq& a, UnpublishStreamReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UnpublishStreamReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnpublishStreamReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnpublishStreamReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnpublishStreamReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnpublishStreamReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnpublishStreamReq& from) {
    UnpublishStreamReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnpublishStreamReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.UnpublishStreamReq";
  }
  protected:
  explicit UnpublishStreamReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 5,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kUserIdFieldNumber = 3,
  };
  // required string token = 5;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.UnpublishStreamReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_type_;
    uint32_t user_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class UnpublishStreamRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.UnpublishStreamRsp) */ {
 public:
  inline UnpublishStreamRsp() : UnpublishStreamRsp(nullptr) {}
  ~UnpublishStreamRsp() override;
  explicit PROTOBUF_CONSTEXPR UnpublishStreamRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnpublishStreamRsp(const UnpublishStreamRsp& from);
  UnpublishStreamRsp(UnpublishStreamRsp&& from) noexcept
    : UnpublishStreamRsp() {
    *this = ::std::move(from);
  }

  inline UnpublishStreamRsp& operator=(const UnpublishStreamRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnpublishStreamRsp& operator=(UnpublishStreamRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnpublishStreamRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnpublishStreamRsp* internal_default_instance() {
    return reinterpret_cast<const UnpublishStreamRsp*>(
               &_UnpublishStreamRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UnpublishStreamRsp& a, UnpublishStreamRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(UnpublishStreamRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnpublishStreamRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnpublishStreamRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnpublishStreamRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnpublishStreamRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnpublishStreamRsp& from) {
    UnpublishStreamRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnpublishStreamRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.UnpublishStreamRsp";
  }
  protected:
  explicit UnpublishStreamRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 6,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kResultFieldNumber = 5,
  };
  // required string msg = 6;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 result = 5;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.UnpublishStreamRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_type_;
    uint32_t user_id_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class SubscribeStreamReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.SubscribeStreamReq) */ {
 public:
  inline SubscribeStreamReq() : SubscribeStreamReq(nullptr) {}
  ~SubscribeStreamReq() override;
  explicit PROTOBUF_CONSTEXPR SubscribeStreamReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeStreamReq(const SubscribeStreamReq& from);
  SubscribeStreamReq(SubscribeStreamReq&& from) noexcept
    : SubscribeStreamReq() {
    *this = ::std::move(from);
  }

  inline SubscribeStreamReq& operator=(const SubscribeStreamReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeStreamReq& operator=(SubscribeStreamReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeStreamReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeStreamReq* internal_default_instance() {
    return reinterpret_cast<const SubscribeStreamReq*>(
               &_SubscribeStreamReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SubscribeStreamReq& a, SubscribeStreamReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeStreamReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeStreamReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeStreamReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeStreamReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeStreamReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribeStreamReq& from) {
    SubscribeStreamReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeStreamReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.SubscribeStreamReq";
  }
  protected:
  explicit SubscribeStreamReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 5,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kUserIdFieldNumber = 3,
  };
  // required string token = 5;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.SubscribeStreamReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_type_;
    uint32_t user_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class SubscribeStreamRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.SubscribeStreamRsp) */ {
 public:
  inline SubscribeStreamRsp() : SubscribeStreamRsp(nullptr) {}
  ~SubscribeStreamRsp() override;
  explicit PROTOBUF_CONSTEXPR SubscribeStreamRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeStreamRsp(const SubscribeStreamRsp& from);
  SubscribeStreamRsp(SubscribeStreamRsp&& from) noexcept
    : SubscribeStreamRsp() {
    *this = ::std::move(from);
  }

  inline SubscribeStreamRsp& operator=(const SubscribeStreamRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeStreamRsp& operator=(SubscribeStreamRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeStreamRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeStreamRsp* internal_default_instance() {
    return reinterpret_cast<const SubscribeStreamRsp*>(
               &_SubscribeStreamRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SubscribeStreamRsp& a, SubscribeStreamRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeStreamRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeStreamRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeStreamRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeStreamRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeStreamRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribeStreamRsp& from) {
    SubscribeStreamRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeStreamRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.SubscribeStreamRsp";
  }
  protected:
  explicit SubscribeStreamRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamAddrFieldNumber = 5,
    kMsgFieldNumber = 7,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kResultFieldNumber = 6,
  };
  // required string stream_addr = 5;
  bool has_stream_addr() const;
  private:
  bool _internal_has_stream_addr() const;
  public:
  void clear_stream_addr();
  const std::string& stream_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_addr();
  PROTOBUF_NODISCARD std::string* release_stream_addr();
  void set_allocated_stream_addr(std::string* stream_addr);
  private:
  const std::string& _internal_stream_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_addr(const std::string& value);
  std::string* _internal_mutable_stream_addr();
  public:

  // required string msg = 7;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 result = 6;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.SubscribeStreamRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_addr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_type_;
    uint32_t user_id_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class UnsubscribeStreamReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.UnsubscribeStreamReq) */ {
 public:
  inline UnsubscribeStreamReq() : UnsubscribeStreamReq(nullptr) {}
  ~UnsubscribeStreamReq() override;
  explicit PROTOBUF_CONSTEXPR UnsubscribeStreamReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsubscribeStreamReq(const UnsubscribeStreamReq& from);
  UnsubscribeStreamReq(UnsubscribeStreamReq&& from) noexcept
    : UnsubscribeStreamReq() {
    *this = ::std::move(from);
  }

  inline UnsubscribeStreamReq& operator=(const UnsubscribeStreamReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsubscribeStreamReq& operator=(UnsubscribeStreamReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsubscribeStreamReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsubscribeStreamReq* internal_default_instance() {
    return reinterpret_cast<const UnsubscribeStreamReq*>(
               &_UnsubscribeStreamReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UnsubscribeStreamReq& a, UnsubscribeStreamReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsubscribeStreamReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsubscribeStreamReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsubscribeStreamReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsubscribeStreamReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsubscribeStreamReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnsubscribeStreamReq& from) {
    UnsubscribeStreamReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsubscribeStreamReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.UnsubscribeStreamReq";
  }
  protected:
  explicit UnsubscribeStreamReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 5,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kUserIdFieldNumber = 3,
  };
  // required string token = 5;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.UnsubscribeStreamReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_type_;
    uint32_t user_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class UnsubscribeStreamRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.UnsubscribeStreamRsp) */ {
 public:
  inline UnsubscribeStreamRsp() : UnsubscribeStreamRsp(nullptr) {}
  ~UnsubscribeStreamRsp() override;
  explicit PROTOBUF_CONSTEXPR UnsubscribeStreamRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsubscribeStreamRsp(const UnsubscribeStreamRsp& from);
  UnsubscribeStreamRsp(UnsubscribeStreamRsp&& from) noexcept
    : UnsubscribeStreamRsp() {
    *this = ::std::move(from);
  }

  inline UnsubscribeStreamRsp& operator=(const UnsubscribeStreamRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsubscribeStreamRsp& operator=(UnsubscribeStreamRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsubscribeStreamRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsubscribeStreamRsp* internal_default_instance() {
    return reinterpret_cast<const UnsubscribeStreamRsp*>(
               &_UnsubscribeStreamRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UnsubscribeStreamRsp& a, UnsubscribeStreamRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsubscribeStreamRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsubscribeStreamRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsubscribeStreamRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsubscribeStreamRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsubscribeStreamRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnsubscribeStreamRsp& from) {
    UnsubscribeStreamRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsubscribeStreamRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.UnsubscribeStreamRsp";
  }
  protected:
  explicit UnsubscribeStreamRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 6,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kResultFieldNumber = 5,
  };
  // required string msg = 6;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 result = 5;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.UnsubscribeStreamRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_type_;
    uint32_t user_id_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class LoginSendChannelNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.LoginSendChannelNotify) */ {
 public:
  inline LoginSendChannelNotify() : LoginSendChannelNotify(nullptr) {}
  ~LoginSendChannelNotify() override;
  explicit PROTOBUF_CONSTEXPR LoginSendChannelNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginSendChannelNotify(const LoginSendChannelNotify& from);
  LoginSendChannelNotify(LoginSendChannelNotify&& from) noexcept
    : LoginSendChannelNotify() {
    *this = ::std::move(from);
  }

  inline LoginSendChannelNotify& operator=(const LoginSendChannelNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginSendChannelNotify& operator=(LoginSendChannelNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginSendChannelNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginSendChannelNotify* internal_default_instance() {
    return reinterpret_cast<const LoginSendChannelNotify*>(
               &_LoginSendChannelNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LoginSendChannelNotify& a, LoginSendChannelNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginSendChannelNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginSendChannelNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginSendChannelNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginSendChannelNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginSendChannelNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginSendChannelNotify& from) {
    LoginSendChannelNotify::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginSendChannelNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.LoginSendChannelNotify";
  }
  protected:
  explicit LoginSendChannelNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamAddrFieldNumber = 5,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kUserTypeFieldNumber = 3,
  };
  // required string stream_addr = 5;
  bool has_stream_addr() const;
  private:
  bool _internal_has_stream_addr() const;
  public:
  void clear_stream_addr();
  const std::string& stream_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_addr();
  PROTOBUF_NODISCARD std::string* release_stream_addr();
  void set_allocated_stream_addr(std::string* stream_addr);
  private:
  const std::string& _internal_stream_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_addr(const std::string& value);
  std::string* _internal_mutable_stream_addr();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_id = 2;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 user_type = 3;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.LoginSendChannelNotify)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_addr_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_id_;
    uint32_t user_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class LoginSendChannelAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.LoginSendChannelAck) */ {
 public:
  inline LoginSendChannelAck() : LoginSendChannelAck(nullptr) {}
  ~LoginSendChannelAck() override;
  explicit PROTOBUF_CONSTEXPR LoginSendChannelAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginSendChannelAck(const LoginSendChannelAck& from);
  LoginSendChannelAck(LoginSendChannelAck&& from) noexcept
    : LoginSendChannelAck() {
    *this = ::std::move(from);
  }

  inline LoginSendChannelAck& operator=(const LoginSendChannelAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginSendChannelAck& operator=(LoginSendChannelAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginSendChannelAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginSendChannelAck* internal_default_instance() {
    return reinterpret_cast<const LoginSendChannelAck*>(
               &_LoginSendChannelAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LoginSendChannelAck& a, LoginSendChannelAck& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginSendChannelAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginSendChannelAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginSendChannelAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginSendChannelAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginSendChannelAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginSendChannelAck& from) {
    LoginSendChannelAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginSendChannelAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.LoginSendChannelAck";
  }
  protected:
  explicit LoginSendChannelAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 6,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kUserTypeFieldNumber = 3,
    kResultFieldNumber = 5,
  };
  // required string msg = 6;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_id = 2;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 user_type = 3;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 result = 5;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.LoginSendChannelAck)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_id_;
    uint32_t user_type_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class GetParentNodeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.GetParentNodeReq) */ {
 public:
  inline GetParentNodeReq() : GetParentNodeReq(nullptr) {}
  ~GetParentNodeReq() override;
  explicit PROTOBUF_CONSTEXPR GetParentNodeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetParentNodeReq(const GetParentNodeReq& from);
  GetParentNodeReq(GetParentNodeReq&& from) noexcept
    : GetParentNodeReq() {
    *this = ::std::move(from);
  }

  inline GetParentNodeReq& operator=(const GetParentNodeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetParentNodeReq& operator=(GetParentNodeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetParentNodeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetParentNodeReq* internal_default_instance() {
    return reinterpret_cast<const GetParentNodeReq*>(
               &_GetParentNodeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetParentNodeReq& a, GetParentNodeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetParentNodeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetParentNodeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetParentNodeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetParentNodeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetParentNodeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetParentNodeReq& from) {
    GetParentNodeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetParentNodeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.GetParentNodeReq";
  }
  protected:
  explicit GetParentNodeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceIdFieldNumber = 2,
    kServiceAddrFieldNumber = 3,
    kStreamFieldNumber = 4,
    kServiceTypeFieldNumber = 1,
  };
  // required string instance_id = 2;
  bool has_instance_id() const;
  private:
  bool _internal_has_instance_id() const;
  public:
  void clear_instance_id();
  const std::string& instance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_id();
  PROTOBUF_NODISCARD std::string* release_instance_id();
  void set_allocated_instance_id(std::string* instance_id);
  private:
  const std::string& _internal_instance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_id(const std::string& value);
  std::string* _internal_mutable_instance_id();
  public:

  // required string service_addr = 3;
  bool has_service_addr() const;
  private:
  bool _internal_has_service_addr() const;
  public:
  void clear_service_addr();
  const std::string& service_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_addr();
  PROTOBUF_NODISCARD std::string* release_service_addr();
  void set_allocated_service_addr(std::string* service_addr);
  private:
  const std::string& _internal_service_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_addr(const std::string& value);
  std::string* _internal_mutable_service_addr();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 service_type = 1;
  bool has_service_type() const;
  private:
  bool _internal_has_service_type() const;
  public:
  void clear_service_type();
  uint32_t service_type() const;
  void set_service_type(uint32_t value);
  private:
  uint32_t _internal_service_type() const;
  void _internal_set_service_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.GetParentNodeReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_addr_;
    ::jukey::prot::NetStream* stream_;
    uint32_t service_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class StreamNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.StreamNode) */ {
 public:
  inline StreamNode() : StreamNode(nullptr) {}
  ~StreamNode() override;
  explicit PROTOBUF_CONSTEXPR StreamNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamNode(const StreamNode& from);
  StreamNode(StreamNode&& from) noexcept
    : StreamNode() {
    *this = ::std::move(from);
  }

  inline StreamNode& operator=(const StreamNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamNode& operator=(StreamNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamNode* internal_default_instance() {
    return reinterpret_cast<const StreamNode*>(
               &_StreamNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StreamNode& a, StreamNode& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamNode& from) {
    StreamNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.StreamNode";
  }
  protected:
  explicit StreamNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceIdFieldNumber = 2,
    kServiceAddrFieldNumber = 3,
    kServiceTypeFieldNumber = 1,
  };
  // required string instance_id = 2;
  bool has_instance_id() const;
  private:
  bool _internal_has_instance_id() const;
  public:
  void clear_instance_id();
  const std::string& instance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_id();
  PROTOBUF_NODISCARD std::string* release_instance_id();
  void set_allocated_instance_id(std::string* instance_id);
  private:
  const std::string& _internal_instance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_id(const std::string& value);
  std::string* _internal_mutable_instance_id();
  public:

  // required string service_addr = 3;
  bool has_service_addr() const;
  private:
  bool _internal_has_service_addr() const;
  public:
  void clear_service_addr();
  const std::string& service_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_addr();
  PROTOBUF_NODISCARD std::string* release_service_addr();
  void set_allocated_service_addr(std::string* service_addr);
  private:
  const std::string& _internal_service_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_addr(const std::string& value);
  std::string* _internal_mutable_service_addr();
  public:

  // required uint32 service_type = 1;
  bool has_service_type() const;
  private:
  bool _internal_has_service_type() const;
  public:
  void clear_service_type();
  uint32_t service_type() const;
  void set_service_type(uint32_t value);
  private:
  uint32_t _internal_service_type() const;
  void _internal_set_service_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.StreamNode)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_addr_;
    uint32_t service_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_stream_2eproto;
};
// -------------------------------------------------------------------

class GetParentNodeRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.GetParentNodeRsp) */ {
 public:
  inline GetParentNodeRsp() : GetParentNodeRsp(nullptr) {}
  ~GetParentNodeRsp() override;
  explicit PROTOBUF_CONSTEXPR GetParentNodeRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetParentNodeRsp(const GetParentNodeRsp& from);
  GetParentNodeRsp(GetParentNodeRsp&& from) noexcept
    : GetParentNodeRsp() {
    *this = ::std::move(from);
  }

  inline GetParentNodeRsp& operator=(const GetParentNodeRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetParentNodeRsp& operator=(GetParentNodeRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetParentNodeRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetParentNodeRsp* internal_default_instance() {
    return reinterpret_cast<const GetParentNodeRsp*>(
               &_GetParentNodeRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetParentNodeRsp& a, GetParentNodeRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetParentNodeRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetParentNodeRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetParentNodeRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetParentNodeRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetParentNodeRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetParentNodeRsp& from) {
    GetParentNodeRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetParentNodeRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.GetParentNodeRsp";
  }
  protected:
  explicit GetParentNodeRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 2,
    kStreamFieldNumber = 1,
  };
  // repeated .jukey.prot.StreamNode nodes = 2;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::jukey::prot::StreamNode* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jukey::prot::StreamNode >*
      mutable_nodes();
  private:
  const ::jukey::prot::StreamNode& _internal_nodes(int index) const;
  ::jukey::prot::StreamNode* _internal_add_nodes();
  public:
  const ::jukey::prot::StreamNode& nodes(int index) const;
  ::jukey::prot::StreamNode* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jukey::prot::StreamNode >&
      nodes() const;

  // required .jukey.prot.NetStream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // @@protoc_insertion_point(class_scope:jukey.prot.GetParentNodeRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jukey::prot::StreamNode > nodes_;
    ::jukey::prot::NetStream* stream_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_stream_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PublishStreamReq

// required uint32 app_id = 1;
inline bool PublishStreamReq::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PublishStreamReq::has_app_id() const {
  return _internal_has_app_id();
}
inline void PublishStreamReq::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t PublishStreamReq::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t PublishStreamReq::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.PublishStreamReq.app_id)
  return _internal_app_id();
}
inline void PublishStreamReq::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_id_ = value;
}
inline void PublishStreamReq::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.PublishStreamReq.app_id)
}

// required uint32 user_type = 2;
inline bool PublishStreamReq::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PublishStreamReq::has_user_type() const {
  return _internal_has_user_type();
}
inline void PublishStreamReq::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t PublishStreamReq::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t PublishStreamReq::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.PublishStreamReq.user_type)
  return _internal_user_type();
}
inline void PublishStreamReq::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_type_ = value;
}
inline void PublishStreamReq::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.PublishStreamReq.user_type)
}

// required uint32 user_id = 3;
inline bool PublishStreamReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PublishStreamReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void PublishStreamReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t PublishStreamReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t PublishStreamReq::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.PublishStreamReq.user_id)
  return _internal_user_id();
}
inline void PublishStreamReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_id_ = value;
}
inline void PublishStreamReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.PublishStreamReq.user_id)
}

// required .jukey.prot.NetStream stream = 4;
inline bool PublishStreamReq::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool PublishStreamReq::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& PublishStreamReq::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& PublishStreamReq::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.PublishStreamReq.stream)
  return _internal_stream();
}
inline void PublishStreamReq::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.PublishStreamReq.stream)
}
inline ::jukey::prot::NetStream* PublishStreamReq::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* PublishStreamReq::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.PublishStreamReq.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* PublishStreamReq::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* PublishStreamReq::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.PublishStreamReq.stream)
  return _msg;
}
inline void PublishStreamReq::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.PublishStreamReq.stream)
}

// required string token = 5;
inline bool PublishStreamReq::_internal_has_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PublishStreamReq::has_token() const {
  return _internal_has_token();
}
inline void PublishStreamReq::clear_token() {
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PublishStreamReq::token() const {
  // @@protoc_insertion_point(field_get:jukey.prot.PublishStreamReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishStreamReq::set_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.PublishStreamReq.token)
}
inline std::string* PublishStreamReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:jukey.prot.PublishStreamReq.token)
  return _s;
}
inline const std::string& PublishStreamReq::_internal_token() const {
  return _impl_.token_.Get();
}
inline void PublishStreamReq::_internal_set_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishStreamReq::_internal_mutable_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* PublishStreamReq::release_token() {
  // @@protoc_insertion_point(field_release:jukey.prot.PublishStreamReq.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PublishStreamReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.PublishStreamReq.token)
}

// -------------------------------------------------------------------

// PublishStreamRsp

// required uint32 app_id = 1;
inline bool PublishStreamRsp::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PublishStreamRsp::has_app_id() const {
  return _internal_has_app_id();
}
inline void PublishStreamRsp::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t PublishStreamRsp::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t PublishStreamRsp::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.PublishStreamRsp.app_id)
  return _internal_app_id();
}
inline void PublishStreamRsp::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_id_ = value;
}
inline void PublishStreamRsp::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.PublishStreamRsp.app_id)
}

// required uint32 user_type = 2;
inline bool PublishStreamRsp::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PublishStreamRsp::has_user_type() const {
  return _internal_has_user_type();
}
inline void PublishStreamRsp::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t PublishStreamRsp::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t PublishStreamRsp::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.PublishStreamRsp.user_type)
  return _internal_user_type();
}
inline void PublishStreamRsp::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_type_ = value;
}
inline void PublishStreamRsp::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.PublishStreamRsp.user_type)
}

// required uint32 user_id = 3;
inline bool PublishStreamRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PublishStreamRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void PublishStreamRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t PublishStreamRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t PublishStreamRsp::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.PublishStreamRsp.user_id)
  return _internal_user_id();
}
inline void PublishStreamRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_id_ = value;
}
inline void PublishStreamRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.PublishStreamRsp.user_id)
}

// required .jukey.prot.NetStream stream = 4;
inline bool PublishStreamRsp::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool PublishStreamRsp::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& PublishStreamRsp::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& PublishStreamRsp::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.PublishStreamRsp.stream)
  return _internal_stream();
}
inline void PublishStreamRsp::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.PublishStreamRsp.stream)
}
inline ::jukey::prot::NetStream* PublishStreamRsp::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* PublishStreamRsp::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.PublishStreamRsp.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* PublishStreamRsp::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* PublishStreamRsp::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.PublishStreamRsp.stream)
  return _msg;
}
inline void PublishStreamRsp::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.PublishStreamRsp.stream)
}

// required uint32 result = 5;
inline bool PublishStreamRsp::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PublishStreamRsp::has_result() const {
  return _internal_has_result();
}
inline void PublishStreamRsp::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t PublishStreamRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t PublishStreamRsp::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.PublishStreamRsp.result)
  return _internal_result();
}
inline void PublishStreamRsp::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.result_ = value;
}
inline void PublishStreamRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.PublishStreamRsp.result)
}

// required string msg = 6;
inline bool PublishStreamRsp::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PublishStreamRsp::has_msg() const {
  return _internal_has_msg();
}
inline void PublishStreamRsp::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PublishStreamRsp::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.PublishStreamRsp.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishStreamRsp::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.PublishStreamRsp.msg)
}
inline std::string* PublishStreamRsp::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.PublishStreamRsp.msg)
  return _s;
}
inline const std::string& PublishStreamRsp::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void PublishStreamRsp::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishStreamRsp::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* PublishStreamRsp::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.PublishStreamRsp.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PublishStreamRsp::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.PublishStreamRsp.msg)
}

// -------------------------------------------------------------------

// UnpublishStreamReq

// required uint32 app_id = 1;
inline bool UnpublishStreamReq::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UnpublishStreamReq::has_app_id() const {
  return _internal_has_app_id();
}
inline void UnpublishStreamReq::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UnpublishStreamReq::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t UnpublishStreamReq::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnpublishStreamReq.app_id)
  return _internal_app_id();
}
inline void UnpublishStreamReq::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_id_ = value;
}
inline void UnpublishStreamReq::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnpublishStreamReq.app_id)
}

// required uint32 user_type = 2;
inline bool UnpublishStreamReq::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UnpublishStreamReq::has_user_type() const {
  return _internal_has_user_type();
}
inline void UnpublishStreamReq::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t UnpublishStreamReq::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t UnpublishStreamReq::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnpublishStreamReq.user_type)
  return _internal_user_type();
}
inline void UnpublishStreamReq::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_type_ = value;
}
inline void UnpublishStreamReq::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnpublishStreamReq.user_type)
}

// required uint32 user_id = 3;
inline bool UnpublishStreamReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UnpublishStreamReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void UnpublishStreamReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t UnpublishStreamReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UnpublishStreamReq::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnpublishStreamReq.user_id)
  return _internal_user_id();
}
inline void UnpublishStreamReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_id_ = value;
}
inline void UnpublishStreamReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnpublishStreamReq.user_id)
}

// required .jukey.prot.NetStream stream = 4;
inline bool UnpublishStreamReq::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool UnpublishStreamReq::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& UnpublishStreamReq::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& UnpublishStreamReq::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnpublishStreamReq.stream)
  return _internal_stream();
}
inline void UnpublishStreamReq::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.UnpublishStreamReq.stream)
}
inline ::jukey::prot::NetStream* UnpublishStreamReq::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* UnpublishStreamReq::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.UnpublishStreamReq.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* UnpublishStreamReq::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* UnpublishStreamReq::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.UnpublishStreamReq.stream)
  return _msg;
}
inline void UnpublishStreamReq::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.UnpublishStreamReq.stream)
}

// required string token = 5;
inline bool UnpublishStreamReq::_internal_has_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnpublishStreamReq::has_token() const {
  return _internal_has_token();
}
inline void UnpublishStreamReq::clear_token() {
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnpublishStreamReq::token() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnpublishStreamReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnpublishStreamReq::set_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.UnpublishStreamReq.token)
}
inline std::string* UnpublishStreamReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:jukey.prot.UnpublishStreamReq.token)
  return _s;
}
inline const std::string& UnpublishStreamReq::_internal_token() const {
  return _impl_.token_.Get();
}
inline void UnpublishStreamReq::_internal_set_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* UnpublishStreamReq::_internal_mutable_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* UnpublishStreamReq::release_token() {
  // @@protoc_insertion_point(field_release:jukey.prot.UnpublishStreamReq.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UnpublishStreamReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.UnpublishStreamReq.token)
}

// -------------------------------------------------------------------

// UnpublishStreamRsp

// required uint32 app_id = 1;
inline bool UnpublishStreamRsp::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UnpublishStreamRsp::has_app_id() const {
  return _internal_has_app_id();
}
inline void UnpublishStreamRsp::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UnpublishStreamRsp::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t UnpublishStreamRsp::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnpublishStreamRsp.app_id)
  return _internal_app_id();
}
inline void UnpublishStreamRsp::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_id_ = value;
}
inline void UnpublishStreamRsp::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnpublishStreamRsp.app_id)
}

// required uint32 user_type = 2;
inline bool UnpublishStreamRsp::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UnpublishStreamRsp::has_user_type() const {
  return _internal_has_user_type();
}
inline void UnpublishStreamRsp::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t UnpublishStreamRsp::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t UnpublishStreamRsp::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnpublishStreamRsp.user_type)
  return _internal_user_type();
}
inline void UnpublishStreamRsp::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_type_ = value;
}
inline void UnpublishStreamRsp::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnpublishStreamRsp.user_type)
}

// required uint32 user_id = 3;
inline bool UnpublishStreamRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UnpublishStreamRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void UnpublishStreamRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t UnpublishStreamRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UnpublishStreamRsp::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnpublishStreamRsp.user_id)
  return _internal_user_id();
}
inline void UnpublishStreamRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_id_ = value;
}
inline void UnpublishStreamRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnpublishStreamRsp.user_id)
}

// required .jukey.prot.NetStream stream = 4;
inline bool UnpublishStreamRsp::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool UnpublishStreamRsp::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& UnpublishStreamRsp::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& UnpublishStreamRsp::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnpublishStreamRsp.stream)
  return _internal_stream();
}
inline void UnpublishStreamRsp::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.UnpublishStreamRsp.stream)
}
inline ::jukey::prot::NetStream* UnpublishStreamRsp::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* UnpublishStreamRsp::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.UnpublishStreamRsp.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* UnpublishStreamRsp::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* UnpublishStreamRsp::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.UnpublishStreamRsp.stream)
  return _msg;
}
inline void UnpublishStreamRsp::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.UnpublishStreamRsp.stream)
}

// required uint32 result = 5;
inline bool UnpublishStreamRsp::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UnpublishStreamRsp::has_result() const {
  return _internal_has_result();
}
inline void UnpublishStreamRsp::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t UnpublishStreamRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t UnpublishStreamRsp::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnpublishStreamRsp.result)
  return _internal_result();
}
inline void UnpublishStreamRsp::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.result_ = value;
}
inline void UnpublishStreamRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnpublishStreamRsp.result)
}

// required string msg = 6;
inline bool UnpublishStreamRsp::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnpublishStreamRsp::has_msg() const {
  return _internal_has_msg();
}
inline void UnpublishStreamRsp::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnpublishStreamRsp::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnpublishStreamRsp.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnpublishStreamRsp::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.UnpublishStreamRsp.msg)
}
inline std::string* UnpublishStreamRsp::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.UnpublishStreamRsp.msg)
  return _s;
}
inline const std::string& UnpublishStreamRsp::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void UnpublishStreamRsp::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* UnpublishStreamRsp::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* UnpublishStreamRsp::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.UnpublishStreamRsp.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UnpublishStreamRsp::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.UnpublishStreamRsp.msg)
}

// -------------------------------------------------------------------

// SubscribeStreamReq

// required uint32 app_id = 1;
inline bool SubscribeStreamReq::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SubscribeStreamReq::has_app_id() const {
  return _internal_has_app_id();
}
inline void SubscribeStreamReq::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t SubscribeStreamReq::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t SubscribeStreamReq::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.SubscribeStreamReq.app_id)
  return _internal_app_id();
}
inline void SubscribeStreamReq::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_id_ = value;
}
inline void SubscribeStreamReq::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.SubscribeStreamReq.app_id)
}

// required uint32 user_type = 2;
inline bool SubscribeStreamReq::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SubscribeStreamReq::has_user_type() const {
  return _internal_has_user_type();
}
inline void SubscribeStreamReq::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t SubscribeStreamReq::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t SubscribeStreamReq::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.SubscribeStreamReq.user_type)
  return _internal_user_type();
}
inline void SubscribeStreamReq::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_type_ = value;
}
inline void SubscribeStreamReq::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.SubscribeStreamReq.user_type)
}

// required uint32 user_id = 3;
inline bool SubscribeStreamReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SubscribeStreamReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void SubscribeStreamReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t SubscribeStreamReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t SubscribeStreamReq::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.SubscribeStreamReq.user_id)
  return _internal_user_id();
}
inline void SubscribeStreamReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_id_ = value;
}
inline void SubscribeStreamReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.SubscribeStreamReq.user_id)
}

// required .jukey.prot.NetStream stream = 4;
inline bool SubscribeStreamReq::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool SubscribeStreamReq::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& SubscribeStreamReq::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& SubscribeStreamReq::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.SubscribeStreamReq.stream)
  return _internal_stream();
}
inline void SubscribeStreamReq::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.SubscribeStreamReq.stream)
}
inline ::jukey::prot::NetStream* SubscribeStreamReq::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* SubscribeStreamReq::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.SubscribeStreamReq.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* SubscribeStreamReq::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* SubscribeStreamReq::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.SubscribeStreamReq.stream)
  return _msg;
}
inline void SubscribeStreamReq::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.SubscribeStreamReq.stream)
}

// required string token = 5;
inline bool SubscribeStreamReq::_internal_has_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SubscribeStreamReq::has_token() const {
  return _internal_has_token();
}
inline void SubscribeStreamReq::clear_token() {
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubscribeStreamReq::token() const {
  // @@protoc_insertion_point(field_get:jukey.prot.SubscribeStreamReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeStreamReq::set_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.SubscribeStreamReq.token)
}
inline std::string* SubscribeStreamReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:jukey.prot.SubscribeStreamReq.token)
  return _s;
}
inline const std::string& SubscribeStreamReq::_internal_token() const {
  return _impl_.token_.Get();
}
inline void SubscribeStreamReq::_internal_set_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscribeStreamReq::_internal_mutable_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscribeStreamReq::release_token() {
  // @@protoc_insertion_point(field_release:jukey.prot.SubscribeStreamReq.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SubscribeStreamReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.SubscribeStreamReq.token)
}

// -------------------------------------------------------------------

// SubscribeStreamRsp

// required uint32 app_id = 1;
inline bool SubscribeStreamRsp::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SubscribeStreamRsp::has_app_id() const {
  return _internal_has_app_id();
}
inline void SubscribeStreamRsp::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t SubscribeStreamRsp::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t SubscribeStreamRsp::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.SubscribeStreamRsp.app_id)
  return _internal_app_id();
}
inline void SubscribeStreamRsp::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.app_id_ = value;
}
inline void SubscribeStreamRsp::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.SubscribeStreamRsp.app_id)
}

// required uint32 user_type = 2;
inline bool SubscribeStreamRsp::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SubscribeStreamRsp::has_user_type() const {
  return _internal_has_user_type();
}
inline void SubscribeStreamRsp::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t SubscribeStreamRsp::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t SubscribeStreamRsp::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.SubscribeStreamRsp.user_type)
  return _internal_user_type();
}
inline void SubscribeStreamRsp::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_type_ = value;
}
inline void SubscribeStreamRsp::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.SubscribeStreamRsp.user_type)
}

// required uint32 user_id = 3;
inline bool SubscribeStreamRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SubscribeStreamRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void SubscribeStreamRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t SubscribeStreamRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t SubscribeStreamRsp::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.SubscribeStreamRsp.user_id)
  return _internal_user_id();
}
inline void SubscribeStreamRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.user_id_ = value;
}
inline void SubscribeStreamRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.SubscribeStreamRsp.user_id)
}

// required .jukey.prot.NetStream stream = 4;
inline bool SubscribeStreamRsp::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool SubscribeStreamRsp::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& SubscribeStreamRsp::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& SubscribeStreamRsp::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.SubscribeStreamRsp.stream)
  return _internal_stream();
}
inline void SubscribeStreamRsp::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.SubscribeStreamRsp.stream)
}
inline ::jukey::prot::NetStream* SubscribeStreamRsp::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* SubscribeStreamRsp::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.SubscribeStreamRsp.stream)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* SubscribeStreamRsp::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* SubscribeStreamRsp::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.SubscribeStreamRsp.stream)
  return _msg;
}
inline void SubscribeStreamRsp::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.SubscribeStreamRsp.stream)
}

// required string stream_addr = 5;
inline bool SubscribeStreamRsp::_internal_has_stream_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SubscribeStreamRsp::has_stream_addr() const {
  return _internal_has_stream_addr();
}
inline void SubscribeStreamRsp::clear_stream_addr() {
  _impl_.stream_addr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubscribeStreamRsp::stream_addr() const {
  // @@protoc_insertion_point(field_get:jukey.prot.SubscribeStreamRsp.stream_addr)
  return _internal_stream_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeStreamRsp::set_stream_addr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stream_addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.SubscribeStreamRsp.stream_addr)
}
inline std::string* SubscribeStreamRsp::mutable_stream_addr() {
  std::string* _s = _internal_mutable_stream_addr();
  // @@protoc_insertion_point(field_mutable:jukey.prot.SubscribeStreamRsp.stream_addr)
  return _s;
}
inline const std::string& SubscribeStreamRsp::_internal_stream_addr() const {
  return _impl_.stream_addr_.Get();
}
inline void SubscribeStreamRsp::_internal_set_stream_addr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stream_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscribeStreamRsp::_internal_mutable_stream_addr() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stream_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscribeStreamRsp::release_stream_addr() {
  // @@protoc_insertion_point(field_release:jukey.prot.SubscribeStreamRsp.stream_addr)
  if (!_internal_has_stream_addr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stream_addr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_addr_.IsDefault()) {
    _impl_.stream_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SubscribeStreamRsp::set_allocated_stream_addr(std::string* stream_addr) {
  if (stream_addr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stream_addr_.SetAllocated(stream_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_addr_.IsDefault()) {
    _impl_.stream_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.SubscribeStreamRsp.stream_addr)
}

// required uint32 result = 6;
inline bool SubscribeStreamRsp::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SubscribeStreamRsp::has_result() const {
  return _internal_has_result();
}
inline void SubscribeStreamRsp::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t SubscribeStreamRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t SubscribeStreamRsp::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.SubscribeStreamRsp.result)
  return _internal_result();
}
inline void SubscribeStreamRsp::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.result_ = value;
}
inline void SubscribeStreamRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.SubscribeStreamRsp.result)
}

// required string msg = 7;
inline bool SubscribeStreamRsp::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SubscribeStreamRsp::has_msg() const {
  return _internal_has_msg();
}
inline void SubscribeStreamRsp::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SubscribeStreamRsp::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.SubscribeStreamRsp.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeStreamRsp::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.SubscribeStreamRsp.msg)
}
inline std::string* SubscribeStreamRsp::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.SubscribeStreamRsp.msg)
  return _s;
}
inline const std::string& SubscribeStreamRsp::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void SubscribeStreamRsp::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscribeStreamRsp::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscribeStreamRsp::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.SubscribeStreamRsp.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SubscribeStreamRsp::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.SubscribeStreamRsp.msg)
}

// -------------------------------------------------------------------

// UnsubscribeStreamReq

// required uint32 app_id = 1;
inline bool UnsubscribeStreamReq::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UnsubscribeStreamReq::has_app_id() const {
  return _internal_has_app_id();
}
inline void UnsubscribeStreamReq::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UnsubscribeStreamReq::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t UnsubscribeStreamReq::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnsubscribeStreamReq.app_id)
  return _internal_app_id();
}
inline void UnsubscribeStreamReq::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_id_ = value;
}
inline void UnsubscribeStreamReq::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnsubscribeStreamReq.app_id)
}

// required uint32 user_type = 2;
inline bool UnsubscribeStreamReq::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UnsubscribeStreamReq::has_user_type() const {
  return _internal_has_user_type();
}
inline void UnsubscribeStreamReq::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t UnsubscribeStreamReq::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t UnsubscribeStreamReq::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnsubscribeStreamReq.user_type)
  return _internal_user_type();
}
inline void UnsubscribeStreamReq::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_type_ = value;
}
inline void UnsubscribeStreamReq::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnsubscribeStreamReq.user_type)
}

// required uint32 user_id = 3;
inline bool UnsubscribeStreamReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UnsubscribeStreamReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void UnsubscribeStreamReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t UnsubscribeStreamReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UnsubscribeStreamReq::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnsubscribeStreamReq.user_id)
  return _internal_user_id();
}
inline void UnsubscribeStreamReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_id_ = value;
}
inline void UnsubscribeStreamReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnsubscribeStreamReq.user_id)
}

// required .jukey.prot.NetStream stream = 4;
inline bool UnsubscribeStreamReq::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool UnsubscribeStreamReq::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& UnsubscribeStreamReq::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& UnsubscribeStreamReq::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnsubscribeStreamReq.stream)
  return _internal_stream();
}
inline void UnsubscribeStreamReq::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.UnsubscribeStreamReq.stream)
}
inline ::jukey::prot::NetStream* UnsubscribeStreamReq::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* UnsubscribeStreamReq::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.UnsubscribeStreamReq.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* UnsubscribeStreamReq::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* UnsubscribeStreamReq::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.UnsubscribeStreamReq.stream)
  return _msg;
}
inline void UnsubscribeStreamReq::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.UnsubscribeStreamReq.stream)
}

// required string token = 5;
inline bool UnsubscribeStreamReq::_internal_has_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnsubscribeStreamReq::has_token() const {
  return _internal_has_token();
}
inline void UnsubscribeStreamReq::clear_token() {
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnsubscribeStreamReq::token() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnsubscribeStreamReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnsubscribeStreamReq::set_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.UnsubscribeStreamReq.token)
}
inline std::string* UnsubscribeStreamReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:jukey.prot.UnsubscribeStreamReq.token)
  return _s;
}
inline const std::string& UnsubscribeStreamReq::_internal_token() const {
  return _impl_.token_.Get();
}
inline void UnsubscribeStreamReq::_internal_set_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* UnsubscribeStreamReq::_internal_mutable_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* UnsubscribeStreamReq::release_token() {
  // @@protoc_insertion_point(field_release:jukey.prot.UnsubscribeStreamReq.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UnsubscribeStreamReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.UnsubscribeStreamReq.token)
}

// -------------------------------------------------------------------

// UnsubscribeStreamRsp

// required uint32 app_id = 1;
inline bool UnsubscribeStreamRsp::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UnsubscribeStreamRsp::has_app_id() const {
  return _internal_has_app_id();
}
inline void UnsubscribeStreamRsp::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UnsubscribeStreamRsp::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t UnsubscribeStreamRsp::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnsubscribeStreamRsp.app_id)
  return _internal_app_id();
}
inline void UnsubscribeStreamRsp::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_id_ = value;
}
inline void UnsubscribeStreamRsp::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnsubscribeStreamRsp.app_id)
}

// required uint32 user_type = 2;
inline bool UnsubscribeStreamRsp::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UnsubscribeStreamRsp::has_user_type() const {
  return _internal_has_user_type();
}
inline void UnsubscribeStreamRsp::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t UnsubscribeStreamRsp::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t UnsubscribeStreamRsp::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnsubscribeStreamRsp.user_type)
  return _internal_user_type();
}
inline void UnsubscribeStreamRsp::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_type_ = value;
}
inline void UnsubscribeStreamRsp::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnsubscribeStreamRsp.user_type)
}

// required uint32 user_id = 3;
inline bool UnsubscribeStreamRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UnsubscribeStreamRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void UnsubscribeStreamRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t UnsubscribeStreamRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t UnsubscribeStreamRsp::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnsubscribeStreamRsp.user_id)
  return _internal_user_id();
}
inline void UnsubscribeStreamRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_id_ = value;
}
inline void UnsubscribeStreamRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnsubscribeStreamRsp.user_id)
}

// required .jukey.prot.NetStream stream = 4;
inline bool UnsubscribeStreamRsp::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool UnsubscribeStreamRsp::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& UnsubscribeStreamRsp::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& UnsubscribeStreamRsp::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnsubscribeStreamRsp.stream)
  return _internal_stream();
}
inline void UnsubscribeStreamRsp::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.UnsubscribeStreamRsp.stream)
}
inline ::jukey::prot::NetStream* UnsubscribeStreamRsp::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* UnsubscribeStreamRsp::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.UnsubscribeStreamRsp.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* UnsubscribeStreamRsp::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* UnsubscribeStreamRsp::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.UnsubscribeStreamRsp.stream)
  return _msg;
}
inline void UnsubscribeStreamRsp::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.UnsubscribeStreamRsp.stream)
}

// required uint32 result = 5;
inline bool UnsubscribeStreamRsp::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UnsubscribeStreamRsp::has_result() const {
  return _internal_has_result();
}
inline void UnsubscribeStreamRsp::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t UnsubscribeStreamRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t UnsubscribeStreamRsp::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnsubscribeStreamRsp.result)
  return _internal_result();
}
inline void UnsubscribeStreamRsp::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.result_ = value;
}
inline void UnsubscribeStreamRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.UnsubscribeStreamRsp.result)
}

// required string msg = 6;
inline bool UnsubscribeStreamRsp::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnsubscribeStreamRsp::has_msg() const {
  return _internal_has_msg();
}
inline void UnsubscribeStreamRsp::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnsubscribeStreamRsp::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.UnsubscribeStreamRsp.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnsubscribeStreamRsp::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.UnsubscribeStreamRsp.msg)
}
inline std::string* UnsubscribeStreamRsp::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.UnsubscribeStreamRsp.msg)
  return _s;
}
inline const std::string& UnsubscribeStreamRsp::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void UnsubscribeStreamRsp::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* UnsubscribeStreamRsp::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* UnsubscribeStreamRsp::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.UnsubscribeStreamRsp.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UnsubscribeStreamRsp::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.UnsubscribeStreamRsp.msg)
}

// -------------------------------------------------------------------

// LoginSendChannelNotify

// required uint32 app_id = 1;
inline bool LoginSendChannelNotify::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LoginSendChannelNotify::has_app_id() const {
  return _internal_has_app_id();
}
inline void LoginSendChannelNotify::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LoginSendChannelNotify::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t LoginSendChannelNotify::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelNotify.app_id)
  return _internal_app_id();
}
inline void LoginSendChannelNotify::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_id_ = value;
}
inline void LoginSendChannelNotify::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelNotify.app_id)
}

// required uint32 user_id = 2;
inline bool LoginSendChannelNotify::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LoginSendChannelNotify::has_user_id() const {
  return _internal_has_user_id();
}
inline void LoginSendChannelNotify::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t LoginSendChannelNotify::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t LoginSendChannelNotify::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelNotify.user_id)
  return _internal_user_id();
}
inline void LoginSendChannelNotify::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_id_ = value;
}
inline void LoginSendChannelNotify::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelNotify.user_id)
}

// required uint32 user_type = 3;
inline bool LoginSendChannelNotify::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LoginSendChannelNotify::has_user_type() const {
  return _internal_has_user_type();
}
inline void LoginSendChannelNotify::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t LoginSendChannelNotify::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t LoginSendChannelNotify::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelNotify.user_type)
  return _internal_user_type();
}
inline void LoginSendChannelNotify::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_type_ = value;
}
inline void LoginSendChannelNotify::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelNotify.user_type)
}

// required .jukey.prot.NetStream stream = 4;
inline bool LoginSendChannelNotify::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool LoginSendChannelNotify::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& LoginSendChannelNotify::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& LoginSendChannelNotify::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelNotify.stream)
  return _internal_stream();
}
inline void LoginSendChannelNotify::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.LoginSendChannelNotify.stream)
}
inline ::jukey::prot::NetStream* LoginSendChannelNotify::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* LoginSendChannelNotify::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.LoginSendChannelNotify.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* LoginSendChannelNotify::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* LoginSendChannelNotify::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LoginSendChannelNotify.stream)
  return _msg;
}
inline void LoginSendChannelNotify::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LoginSendChannelNotify.stream)
}

// required string stream_addr = 5;
inline bool LoginSendChannelNotify::_internal_has_stream_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginSendChannelNotify::has_stream_addr() const {
  return _internal_has_stream_addr();
}
inline void LoginSendChannelNotify::clear_stream_addr() {
  _impl_.stream_addr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginSendChannelNotify::stream_addr() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelNotify.stream_addr)
  return _internal_stream_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginSendChannelNotify::set_stream_addr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stream_addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelNotify.stream_addr)
}
inline std::string* LoginSendChannelNotify::mutable_stream_addr() {
  std::string* _s = _internal_mutable_stream_addr();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LoginSendChannelNotify.stream_addr)
  return _s;
}
inline const std::string& LoginSendChannelNotify::_internal_stream_addr() const {
  return _impl_.stream_addr_.Get();
}
inline void LoginSendChannelNotify::_internal_set_stream_addr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stream_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginSendChannelNotify::_internal_mutable_stream_addr() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stream_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginSendChannelNotify::release_stream_addr() {
  // @@protoc_insertion_point(field_release:jukey.prot.LoginSendChannelNotify.stream_addr)
  if (!_internal_has_stream_addr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stream_addr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_addr_.IsDefault()) {
    _impl_.stream_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginSendChannelNotify::set_allocated_stream_addr(std::string* stream_addr) {
  if (stream_addr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stream_addr_.SetAllocated(stream_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_addr_.IsDefault()) {
    _impl_.stream_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LoginSendChannelNotify.stream_addr)
}

// -------------------------------------------------------------------

// LoginSendChannelAck

// required uint32 app_id = 1;
inline bool LoginSendChannelAck::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LoginSendChannelAck::has_app_id() const {
  return _internal_has_app_id();
}
inline void LoginSendChannelAck::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LoginSendChannelAck::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t LoginSendChannelAck::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelAck.app_id)
  return _internal_app_id();
}
inline void LoginSendChannelAck::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_id_ = value;
}
inline void LoginSendChannelAck::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelAck.app_id)
}

// required uint32 user_id = 2;
inline bool LoginSendChannelAck::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LoginSendChannelAck::has_user_id() const {
  return _internal_has_user_id();
}
inline void LoginSendChannelAck::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t LoginSendChannelAck::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t LoginSendChannelAck::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelAck.user_id)
  return _internal_user_id();
}
inline void LoginSendChannelAck::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_id_ = value;
}
inline void LoginSendChannelAck::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelAck.user_id)
}

// required uint32 user_type = 3;
inline bool LoginSendChannelAck::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LoginSendChannelAck::has_user_type() const {
  return _internal_has_user_type();
}
inline void LoginSendChannelAck::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t LoginSendChannelAck::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t LoginSendChannelAck::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelAck.user_type)
  return _internal_user_type();
}
inline void LoginSendChannelAck::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_type_ = value;
}
inline void LoginSendChannelAck::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelAck.user_type)
}

// required .jukey.prot.NetStream stream = 4;
inline bool LoginSendChannelAck::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool LoginSendChannelAck::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& LoginSendChannelAck::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& LoginSendChannelAck::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelAck.stream)
  return _internal_stream();
}
inline void LoginSendChannelAck::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.LoginSendChannelAck.stream)
}
inline ::jukey::prot::NetStream* LoginSendChannelAck::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* LoginSendChannelAck::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.LoginSendChannelAck.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* LoginSendChannelAck::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* LoginSendChannelAck::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LoginSendChannelAck.stream)
  return _msg;
}
inline void LoginSendChannelAck::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LoginSendChannelAck.stream)
}

// required uint32 result = 5;
inline bool LoginSendChannelAck::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LoginSendChannelAck::has_result() const {
  return _internal_has_result();
}
inline void LoginSendChannelAck::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t LoginSendChannelAck::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t LoginSendChannelAck::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelAck.result)
  return _internal_result();
}
inline void LoginSendChannelAck::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.result_ = value;
}
inline void LoginSendChannelAck::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelAck.result)
}

// required string msg = 6;
inline bool LoginSendChannelAck::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginSendChannelAck::has_msg() const {
  return _internal_has_msg();
}
inline void LoginSendChannelAck::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginSendChannelAck::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginSendChannelAck::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelAck.msg)
}
inline std::string* LoginSendChannelAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LoginSendChannelAck.msg)
  return _s;
}
inline const std::string& LoginSendChannelAck::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void LoginSendChannelAck::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginSendChannelAck::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginSendChannelAck::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.LoginSendChannelAck.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginSendChannelAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LoginSendChannelAck.msg)
}

// -------------------------------------------------------------------

// GetParentNodeReq

// required uint32 service_type = 1;
inline bool GetParentNodeReq::_internal_has_service_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GetParentNodeReq::has_service_type() const {
  return _internal_has_service_type();
}
inline void GetParentNodeReq::clear_service_type() {
  _impl_.service_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t GetParentNodeReq::_internal_service_type() const {
  return _impl_.service_type_;
}
inline uint32_t GetParentNodeReq::service_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.GetParentNodeReq.service_type)
  return _internal_service_type();
}
inline void GetParentNodeReq::_internal_set_service_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.service_type_ = value;
}
inline void GetParentNodeReq::set_service_type(uint32_t value) {
  _internal_set_service_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.GetParentNodeReq.service_type)
}

// required string instance_id = 2;
inline bool GetParentNodeReq::_internal_has_instance_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetParentNodeReq::has_instance_id() const {
  return _internal_has_instance_id();
}
inline void GetParentNodeReq::clear_instance_id() {
  _impl_.instance_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetParentNodeReq::instance_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.GetParentNodeReq.instance_id)
  return _internal_instance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetParentNodeReq::set_instance_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.instance_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.GetParentNodeReq.instance_id)
}
inline std::string* GetParentNodeReq::mutable_instance_id() {
  std::string* _s = _internal_mutable_instance_id();
  // @@protoc_insertion_point(field_mutable:jukey.prot.GetParentNodeReq.instance_id)
  return _s;
}
inline const std::string& GetParentNodeReq::_internal_instance_id() const {
  return _impl_.instance_id_.Get();
}
inline void GetParentNodeReq::_internal_set_instance_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.instance_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetParentNodeReq::_internal_mutable_instance_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.instance_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetParentNodeReq::release_instance_id() {
  // @@protoc_insertion_point(field_release:jukey.prot.GetParentNodeReq.instance_id)
  if (!_internal_has_instance_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.instance_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetParentNodeReq::set_allocated_instance_id(std::string* instance_id) {
  if (instance_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.instance_id_.SetAllocated(instance_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.GetParentNodeReq.instance_id)
}

// required string service_addr = 3;
inline bool GetParentNodeReq::_internal_has_service_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetParentNodeReq::has_service_addr() const {
  return _internal_has_service_addr();
}
inline void GetParentNodeReq::clear_service_addr() {
  _impl_.service_addr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetParentNodeReq::service_addr() const {
  // @@protoc_insertion_point(field_get:jukey.prot.GetParentNodeReq.service_addr)
  return _internal_service_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetParentNodeReq::set_service_addr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.service_addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.GetParentNodeReq.service_addr)
}
inline std::string* GetParentNodeReq::mutable_service_addr() {
  std::string* _s = _internal_mutable_service_addr();
  // @@protoc_insertion_point(field_mutable:jukey.prot.GetParentNodeReq.service_addr)
  return _s;
}
inline const std::string& GetParentNodeReq::_internal_service_addr() const {
  return _impl_.service_addr_.Get();
}
inline void GetParentNodeReq::_internal_set_service_addr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.service_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* GetParentNodeReq::_internal_mutable_service_addr() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.service_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* GetParentNodeReq::release_service_addr() {
  // @@protoc_insertion_point(field_release:jukey.prot.GetParentNodeReq.service_addr)
  if (!_internal_has_service_addr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.service_addr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_addr_.IsDefault()) {
    _impl_.service_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetParentNodeReq::set_allocated_service_addr(std::string* service_addr) {
  if (service_addr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.service_addr_.SetAllocated(service_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_addr_.IsDefault()) {
    _impl_.service_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.GetParentNodeReq.service_addr)
}

// required .jukey.prot.NetStream stream = 4;
inline bool GetParentNodeReq::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool GetParentNodeReq::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& GetParentNodeReq::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& GetParentNodeReq::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.GetParentNodeReq.stream)
  return _internal_stream();
}
inline void GetParentNodeReq::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.GetParentNodeReq.stream)
}
inline ::jukey::prot::NetStream* GetParentNodeReq::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* GetParentNodeReq::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.GetParentNodeReq.stream)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* GetParentNodeReq::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* GetParentNodeReq::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.GetParentNodeReq.stream)
  return _msg;
}
inline void GetParentNodeReq::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.GetParentNodeReq.stream)
}

// -------------------------------------------------------------------

// StreamNode

// required uint32 service_type = 1;
inline bool StreamNode::_internal_has_service_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StreamNode::has_service_type() const {
  return _internal_has_service_type();
}
inline void StreamNode::clear_service_type() {
  _impl_.service_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t StreamNode::_internal_service_type() const {
  return _impl_.service_type_;
}
inline uint32_t StreamNode::service_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.StreamNode.service_type)
  return _internal_service_type();
}
inline void StreamNode::_internal_set_service_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.service_type_ = value;
}
inline void StreamNode::set_service_type(uint32_t value) {
  _internal_set_service_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.StreamNode.service_type)
}

// required string instance_id = 2;
inline bool StreamNode::_internal_has_instance_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StreamNode::has_instance_id() const {
  return _internal_has_instance_id();
}
inline void StreamNode::clear_instance_id() {
  _impl_.instance_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StreamNode::instance_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.StreamNode.instance_id)
  return _internal_instance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamNode::set_instance_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.instance_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.StreamNode.instance_id)
}
inline std::string* StreamNode::mutable_instance_id() {
  std::string* _s = _internal_mutable_instance_id();
  // @@protoc_insertion_point(field_mutable:jukey.prot.StreamNode.instance_id)
  return _s;
}
inline const std::string& StreamNode::_internal_instance_id() const {
  return _impl_.instance_id_.Get();
}
inline void StreamNode::_internal_set_instance_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.instance_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamNode::_internal_mutable_instance_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.instance_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamNode::release_instance_id() {
  // @@protoc_insertion_point(field_release:jukey.prot.StreamNode.instance_id)
  if (!_internal_has_instance_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.instance_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StreamNode::set_allocated_instance_id(std::string* instance_id) {
  if (instance_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.instance_id_.SetAllocated(instance_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_id_.IsDefault()) {
    _impl_.instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.StreamNode.instance_id)
}

// required string service_addr = 3;
inline bool StreamNode::_internal_has_service_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StreamNode::has_service_addr() const {
  return _internal_has_service_addr();
}
inline void StreamNode::clear_service_addr() {
  _impl_.service_addr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StreamNode::service_addr() const {
  // @@protoc_insertion_point(field_get:jukey.prot.StreamNode.service_addr)
  return _internal_service_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamNode::set_service_addr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.service_addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.StreamNode.service_addr)
}
inline std::string* StreamNode::mutable_service_addr() {
  std::string* _s = _internal_mutable_service_addr();
  // @@protoc_insertion_point(field_mutable:jukey.prot.StreamNode.service_addr)
  return _s;
}
inline const std::string& StreamNode::_internal_service_addr() const {
  return _impl_.service_addr_.Get();
}
inline void StreamNode::_internal_set_service_addr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.service_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamNode::_internal_mutable_service_addr() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.service_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamNode::release_service_addr() {
  // @@protoc_insertion_point(field_release:jukey.prot.StreamNode.service_addr)
  if (!_internal_has_service_addr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.service_addr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_addr_.IsDefault()) {
    _impl_.service_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StreamNode::set_allocated_service_addr(std::string* service_addr) {
  if (service_addr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.service_addr_.SetAllocated(service_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_addr_.IsDefault()) {
    _impl_.service_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.StreamNode.service_addr)
}

// -------------------------------------------------------------------

// GetParentNodeRsp

// required .jukey.prot.NetStream stream = 1;
inline bool GetParentNodeRsp::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool GetParentNodeRsp::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& GetParentNodeRsp::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& GetParentNodeRsp::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.GetParentNodeRsp.stream)
  return _internal_stream();
}
inline void GetParentNodeRsp::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.GetParentNodeRsp.stream)
}
inline ::jukey::prot::NetStream* GetParentNodeRsp::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* GetParentNodeRsp::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.GetParentNodeRsp.stream)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* GetParentNodeRsp::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* GetParentNodeRsp::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.GetParentNodeRsp.stream)
  return _msg;
}
inline void GetParentNodeRsp::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.GetParentNodeRsp.stream)
}

// repeated .jukey.prot.StreamNode nodes = 2;
inline int GetParentNodeRsp::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int GetParentNodeRsp::nodes_size() const {
  return _internal_nodes_size();
}
inline void GetParentNodeRsp::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::jukey::prot::StreamNode* GetParentNodeRsp::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:jukey.prot.GetParentNodeRsp.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jukey::prot::StreamNode >*
GetParentNodeRsp::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:jukey.prot.GetParentNodeRsp.nodes)
  return &_impl_.nodes_;
}
inline const ::jukey::prot::StreamNode& GetParentNodeRsp::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::jukey::prot::StreamNode& GetParentNodeRsp::nodes(int index) const {
  // @@protoc_insertion_point(field_get:jukey.prot.GetParentNodeRsp.nodes)
  return _internal_nodes(index);
}
inline ::jukey::prot::StreamNode* GetParentNodeRsp::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::jukey::prot::StreamNode* GetParentNodeRsp::add_nodes() {
  ::jukey::prot::StreamNode* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:jukey.prot.GetParentNodeRsp.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::jukey::prot::StreamNode >&
GetParentNodeRsp::nodes() const {
  // @@protoc_insertion_point(field_list:jukey.prot.GetParentNodeRsp.nodes)
  return _impl_.nodes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace prot
}  // namespace jukey

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_stream_2eproto
