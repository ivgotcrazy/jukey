// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: transport.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_transport_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_transport_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_transport_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_transport_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_transport_2eproto;
namespace jukey {
namespace prot {
class LoginRecvChannelReq;
struct LoginRecvChannelReqDefaultTypeInternal;
extern LoginRecvChannelReqDefaultTypeInternal _LoginRecvChannelReq_default_instance_;
class LoginRecvChannelRsp;
struct LoginRecvChannelRspDefaultTypeInternal;
extern LoginRecvChannelRspDefaultTypeInternal _LoginRecvChannelRsp_default_instance_;
class LoginSendChannelReq;
struct LoginSendChannelReqDefaultTypeInternal;
extern LoginSendChannelReqDefaultTypeInternal _LoginSendChannelReq_default_instance_;
class LoginSendChannelRsp;
struct LoginSendChannelRspDefaultTypeInternal;
extern LoginSendChannelRspDefaultTypeInternal _LoginSendChannelRsp_default_instance_;
class LogoutRecvChannelReq;
struct LogoutRecvChannelReqDefaultTypeInternal;
extern LogoutRecvChannelReqDefaultTypeInternal _LogoutRecvChannelReq_default_instance_;
class LogoutRecvChannelRsp;
struct LogoutRecvChannelRspDefaultTypeInternal;
extern LogoutRecvChannelRspDefaultTypeInternal _LogoutRecvChannelRsp_default_instance_;
class LogoutSendChannelReq;
struct LogoutSendChannelReqDefaultTypeInternal;
extern LogoutSendChannelReqDefaultTypeInternal _LogoutSendChannelReq_default_instance_;
class LogoutSendChannelRsp;
struct LogoutSendChannelRspDefaultTypeInternal;
extern LogoutSendChannelRspDefaultTypeInternal _LogoutSendChannelRsp_default_instance_;
class NegotiateReq;
struct NegotiateReqDefaultTypeInternal;
extern NegotiateReqDefaultTypeInternal _NegotiateReq_default_instance_;
class NegotiateRsp;
struct NegotiateRspDefaultTypeInternal;
extern NegotiateRspDefaultTypeInternal _NegotiateRsp_default_instance_;
class PauseRecvStreamReq;
struct PauseRecvStreamReqDefaultTypeInternal;
extern PauseRecvStreamReqDefaultTypeInternal _PauseRecvStreamReq_default_instance_;
class PauseRecvStreamRsp;
struct PauseRecvStreamRspDefaultTypeInternal;
extern PauseRecvStreamRspDefaultTypeInternal _PauseRecvStreamRsp_default_instance_;
class ResumeRecvStreamReq;
struct ResumeRecvStreamReqDefaultTypeInternal;
extern ResumeRecvStreamReqDefaultTypeInternal _ResumeRecvStreamReq_default_instance_;
class ResumeRecvStreamRsp;
struct ResumeRecvStreamRspDefaultTypeInternal;
extern ResumeRecvStreamRspDefaultTypeInternal _ResumeRecvStreamRsp_default_instance_;
class StartSendStreamAck;
struct StartSendStreamAckDefaultTypeInternal;
extern StartSendStreamAckDefaultTypeInternal _StartSendStreamAck_default_instance_;
class StartSendStreamNotify;
struct StartSendStreamNotifyDefaultTypeInternal;
extern StartSendStreamNotifyDefaultTypeInternal _StartSendStreamNotify_default_instance_;
class StopSendStreamAck;
struct StopSendStreamAckDefaultTypeInternal;
extern StopSendStreamAckDefaultTypeInternal _StopSendStreamAck_default_instance_;
class StopSendStreamNotify;
struct StopSendStreamNotifyDefaultTypeInternal;
extern StopSendStreamNotifyDefaultTypeInternal _StopSendStreamNotify_default_instance_;
}  // namespace prot
}  // namespace jukey
PROTOBUF_NAMESPACE_OPEN
template<> ::jukey::prot::LoginRecvChannelReq* Arena::CreateMaybeMessage<::jukey::prot::LoginRecvChannelReq>(Arena*);
template<> ::jukey::prot::LoginRecvChannelRsp* Arena::CreateMaybeMessage<::jukey::prot::LoginRecvChannelRsp>(Arena*);
template<> ::jukey::prot::LoginSendChannelReq* Arena::CreateMaybeMessage<::jukey::prot::LoginSendChannelReq>(Arena*);
template<> ::jukey::prot::LoginSendChannelRsp* Arena::CreateMaybeMessage<::jukey::prot::LoginSendChannelRsp>(Arena*);
template<> ::jukey::prot::LogoutRecvChannelReq* Arena::CreateMaybeMessage<::jukey::prot::LogoutRecvChannelReq>(Arena*);
template<> ::jukey::prot::LogoutRecvChannelRsp* Arena::CreateMaybeMessage<::jukey::prot::LogoutRecvChannelRsp>(Arena*);
template<> ::jukey::prot::LogoutSendChannelReq* Arena::CreateMaybeMessage<::jukey::prot::LogoutSendChannelReq>(Arena*);
template<> ::jukey::prot::LogoutSendChannelRsp* Arena::CreateMaybeMessage<::jukey::prot::LogoutSendChannelRsp>(Arena*);
template<> ::jukey::prot::NegotiateReq* Arena::CreateMaybeMessage<::jukey::prot::NegotiateReq>(Arena*);
template<> ::jukey::prot::NegotiateRsp* Arena::CreateMaybeMessage<::jukey::prot::NegotiateRsp>(Arena*);
template<> ::jukey::prot::PauseRecvStreamReq* Arena::CreateMaybeMessage<::jukey::prot::PauseRecvStreamReq>(Arena*);
template<> ::jukey::prot::PauseRecvStreamRsp* Arena::CreateMaybeMessage<::jukey::prot::PauseRecvStreamRsp>(Arena*);
template<> ::jukey::prot::ResumeRecvStreamReq* Arena::CreateMaybeMessage<::jukey::prot::ResumeRecvStreamReq>(Arena*);
template<> ::jukey::prot::ResumeRecvStreamRsp* Arena::CreateMaybeMessage<::jukey::prot::ResumeRecvStreamRsp>(Arena*);
template<> ::jukey::prot::StartSendStreamAck* Arena::CreateMaybeMessage<::jukey::prot::StartSendStreamAck>(Arena*);
template<> ::jukey::prot::StartSendStreamNotify* Arena::CreateMaybeMessage<::jukey::prot::StartSendStreamNotify>(Arena*);
template<> ::jukey::prot::StopSendStreamAck* Arena::CreateMaybeMessage<::jukey::prot::StopSendStreamAck>(Arena*);
template<> ::jukey::prot::StopSendStreamNotify* Arena::CreateMaybeMessage<::jukey::prot::StopSendStreamNotify>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace jukey {
namespace prot {

// ===================================================================

class LoginSendChannelReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.LoginSendChannelReq) */ {
 public:
  inline LoginSendChannelReq() : LoginSendChannelReq(nullptr) {}
  ~LoginSendChannelReq() override;
  explicit PROTOBUF_CONSTEXPR LoginSendChannelReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginSendChannelReq(const LoginSendChannelReq& from);
  LoginSendChannelReq(LoginSendChannelReq&& from) noexcept
    : LoginSendChannelReq() {
    *this = ::std::move(from);
  }

  inline LoginSendChannelReq& operator=(const LoginSendChannelReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginSendChannelReq& operator=(LoginSendChannelReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginSendChannelReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginSendChannelReq* internal_default_instance() {
    return reinterpret_cast<const LoginSendChannelReq*>(
               &_LoginSendChannelReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LoginSendChannelReq& a, LoginSendChannelReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginSendChannelReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginSendChannelReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginSendChannelReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginSendChannelReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginSendChannelReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginSendChannelReq& from) {
    LoginSendChannelReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginSendChannelReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.LoginSendChannelReq";
  }
  protected:
  explicit LoginSendChannelReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 5,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kUserIdFieldNumber = 3,
  };
  // required string token = 5;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.LoginSendChannelReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_type_;
    uint32_t user_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// -------------------------------------------------------------------

class LoginSendChannelRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.LoginSendChannelRsp) */ {
 public:
  inline LoginSendChannelRsp() : LoginSendChannelRsp(nullptr) {}
  ~LoginSendChannelRsp() override;
  explicit PROTOBUF_CONSTEXPR LoginSendChannelRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginSendChannelRsp(const LoginSendChannelRsp& from);
  LoginSendChannelRsp(LoginSendChannelRsp&& from) noexcept
    : LoginSendChannelRsp() {
    *this = ::std::move(from);
  }

  inline LoginSendChannelRsp& operator=(const LoginSendChannelRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginSendChannelRsp& operator=(LoginSendChannelRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginSendChannelRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginSendChannelRsp* internal_default_instance() {
    return reinterpret_cast<const LoginSendChannelRsp*>(
               &_LoginSendChannelRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoginSendChannelRsp& a, LoginSendChannelRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginSendChannelRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginSendChannelRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginSendChannelRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginSendChannelRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginSendChannelRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginSendChannelRsp& from) {
    LoginSendChannelRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginSendChannelRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.LoginSendChannelRsp";
  }
  protected:
  explicit LoginSendChannelRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 7,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kChannelIdFieldNumber = 5,
    kResultFieldNumber = 6,
  };
  // required string msg = 7;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 channel_id = 5;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint32_t channel_id() const;
  void set_channel_id(uint32_t value);
  private:
  uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(uint32_t value);
  public:

  // required uint32 result = 6;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.LoginSendChannelRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_type_;
    uint32_t user_id_;
    uint32_t channel_id_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// -------------------------------------------------------------------

class LogoutSendChannelReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.LogoutSendChannelReq) */ {
 public:
  inline LogoutSendChannelReq() : LogoutSendChannelReq(nullptr) {}
  ~LogoutSendChannelReq() override;
  explicit PROTOBUF_CONSTEXPR LogoutSendChannelReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutSendChannelReq(const LogoutSendChannelReq& from);
  LogoutSendChannelReq(LogoutSendChannelReq&& from) noexcept
    : LogoutSendChannelReq() {
    *this = ::std::move(from);
  }

  inline LogoutSendChannelReq& operator=(const LogoutSendChannelReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutSendChannelReq& operator=(LogoutSendChannelReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutSendChannelReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutSendChannelReq* internal_default_instance() {
    return reinterpret_cast<const LogoutSendChannelReq*>(
               &_LogoutSendChannelReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LogoutSendChannelReq& a, LogoutSendChannelReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutSendChannelReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutSendChannelReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutSendChannelReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutSendChannelReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutSendChannelReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogoutSendChannelReq& from) {
    LogoutSendChannelReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutSendChannelReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.LogoutSendChannelReq";
  }
  protected:
  explicit LogoutSendChannelReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 6,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kChannelIdFieldNumber = 5,
  };
  // required string token = 6;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 channel_id = 5;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint32_t channel_id() const;
  void set_channel_id(uint32_t value);
  private:
  uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.LogoutSendChannelReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_type_;
    uint32_t user_id_;
    uint32_t channel_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// -------------------------------------------------------------------

class LogoutSendChannelRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.LogoutSendChannelRsp) */ {
 public:
  inline LogoutSendChannelRsp() : LogoutSendChannelRsp(nullptr) {}
  ~LogoutSendChannelRsp() override;
  explicit PROTOBUF_CONSTEXPR LogoutSendChannelRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutSendChannelRsp(const LogoutSendChannelRsp& from);
  LogoutSendChannelRsp(LogoutSendChannelRsp&& from) noexcept
    : LogoutSendChannelRsp() {
    *this = ::std::move(from);
  }

  inline LogoutSendChannelRsp& operator=(const LogoutSendChannelRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutSendChannelRsp& operator=(LogoutSendChannelRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutSendChannelRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutSendChannelRsp* internal_default_instance() {
    return reinterpret_cast<const LogoutSendChannelRsp*>(
               &_LogoutSendChannelRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LogoutSendChannelRsp& a, LogoutSendChannelRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutSendChannelRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutSendChannelRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutSendChannelRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutSendChannelRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutSendChannelRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogoutSendChannelRsp& from) {
    LogoutSendChannelRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutSendChannelRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.LogoutSendChannelRsp";
  }
  protected:
  explicit LogoutSendChannelRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 7,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kChannelIdFieldNumber = 5,
    kResultFieldNumber = 6,
  };
  // required string msg = 7;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 channel_id = 5;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint32_t channel_id() const;
  void set_channel_id(uint32_t value);
  private:
  uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(uint32_t value);
  public:

  // required uint32 result = 6;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.LogoutSendChannelRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_type_;
    uint32_t user_id_;
    uint32_t channel_id_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// -------------------------------------------------------------------

class LoginRecvChannelReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.LoginRecvChannelReq) */ {
 public:
  inline LoginRecvChannelReq() : LoginRecvChannelReq(nullptr) {}
  ~LoginRecvChannelReq() override;
  explicit PROTOBUF_CONSTEXPR LoginRecvChannelReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRecvChannelReq(const LoginRecvChannelReq& from);
  LoginRecvChannelReq(LoginRecvChannelReq&& from) noexcept
    : LoginRecvChannelReq() {
    *this = ::std::move(from);
  }

  inline LoginRecvChannelReq& operator=(const LoginRecvChannelReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRecvChannelReq& operator=(LoginRecvChannelReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRecvChannelReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRecvChannelReq* internal_default_instance() {
    return reinterpret_cast<const LoginRecvChannelReq*>(
               &_LoginRecvChannelReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LoginRecvChannelReq& a, LoginRecvChannelReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRecvChannelReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRecvChannelReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRecvChannelReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRecvChannelReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRecvChannelReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRecvChannelReq& from) {
    LoginRecvChannelReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRecvChannelReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.LoginRecvChannelReq";
  }
  protected:
  explicit LoginRecvChannelReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 5,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kUserIdFieldNumber = 3,
  };
  // required string token = 5;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.LoginRecvChannelReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_type_;
    uint32_t user_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// -------------------------------------------------------------------

class LoginRecvChannelRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.LoginRecvChannelRsp) */ {
 public:
  inline LoginRecvChannelRsp() : LoginRecvChannelRsp(nullptr) {}
  ~LoginRecvChannelRsp() override;
  explicit PROTOBUF_CONSTEXPR LoginRecvChannelRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRecvChannelRsp(const LoginRecvChannelRsp& from);
  LoginRecvChannelRsp(LoginRecvChannelRsp&& from) noexcept
    : LoginRecvChannelRsp() {
    *this = ::std::move(from);
  }

  inline LoginRecvChannelRsp& operator=(const LoginRecvChannelRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRecvChannelRsp& operator=(LoginRecvChannelRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRecvChannelRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRecvChannelRsp* internal_default_instance() {
    return reinterpret_cast<const LoginRecvChannelRsp*>(
               &_LoginRecvChannelRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LoginRecvChannelRsp& a, LoginRecvChannelRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRecvChannelRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRecvChannelRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRecvChannelRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRecvChannelRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRecvChannelRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRecvChannelRsp& from) {
    LoginRecvChannelRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRecvChannelRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.LoginRecvChannelRsp";
  }
  protected:
  explicit LoginRecvChannelRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 7,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kChannelIdFieldNumber = 5,
    kResultFieldNumber = 6,
  };
  // required string msg = 7;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 channel_id = 5;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint32_t channel_id() const;
  void set_channel_id(uint32_t value);
  private:
  uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(uint32_t value);
  public:

  // required uint32 result = 6;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.LoginRecvChannelRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_type_;
    uint32_t user_id_;
    uint32_t channel_id_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// -------------------------------------------------------------------

class LogoutRecvChannelReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.LogoutRecvChannelReq) */ {
 public:
  inline LogoutRecvChannelReq() : LogoutRecvChannelReq(nullptr) {}
  ~LogoutRecvChannelReq() override;
  explicit PROTOBUF_CONSTEXPR LogoutRecvChannelReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutRecvChannelReq(const LogoutRecvChannelReq& from);
  LogoutRecvChannelReq(LogoutRecvChannelReq&& from) noexcept
    : LogoutRecvChannelReq() {
    *this = ::std::move(from);
  }

  inline LogoutRecvChannelReq& operator=(const LogoutRecvChannelReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutRecvChannelReq& operator=(LogoutRecvChannelReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutRecvChannelReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutRecvChannelReq* internal_default_instance() {
    return reinterpret_cast<const LogoutRecvChannelReq*>(
               &_LogoutRecvChannelReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LogoutRecvChannelReq& a, LogoutRecvChannelReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutRecvChannelReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutRecvChannelReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutRecvChannelReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutRecvChannelReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutRecvChannelReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogoutRecvChannelReq& from) {
    LogoutRecvChannelReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutRecvChannelReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.LogoutRecvChannelReq";
  }
  protected:
  explicit LogoutRecvChannelReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 6,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kChannelIdFieldNumber = 5,
  };
  // required string token = 6;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 channel_id = 5;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint32_t channel_id() const;
  void set_channel_id(uint32_t value);
  private:
  uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.LogoutRecvChannelReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_type_;
    uint32_t user_id_;
    uint32_t channel_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// -------------------------------------------------------------------

class LogoutRecvChannelRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.LogoutRecvChannelRsp) */ {
 public:
  inline LogoutRecvChannelRsp() : LogoutRecvChannelRsp(nullptr) {}
  ~LogoutRecvChannelRsp() override;
  explicit PROTOBUF_CONSTEXPR LogoutRecvChannelRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutRecvChannelRsp(const LogoutRecvChannelRsp& from);
  LogoutRecvChannelRsp(LogoutRecvChannelRsp&& from) noexcept
    : LogoutRecvChannelRsp() {
    *this = ::std::move(from);
  }

  inline LogoutRecvChannelRsp& operator=(const LogoutRecvChannelRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutRecvChannelRsp& operator=(LogoutRecvChannelRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutRecvChannelRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutRecvChannelRsp* internal_default_instance() {
    return reinterpret_cast<const LogoutRecvChannelRsp*>(
               &_LogoutRecvChannelRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LogoutRecvChannelRsp& a, LogoutRecvChannelRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutRecvChannelRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutRecvChannelRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutRecvChannelRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutRecvChannelRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutRecvChannelRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogoutRecvChannelRsp& from) {
    LogoutRecvChannelRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutRecvChannelRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.LogoutRecvChannelRsp";
  }
  protected:
  explicit LogoutRecvChannelRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 7,
    kStreamFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kUserTypeFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kChannelIdFieldNumber = 5,
    kResultFieldNumber = 6,
  };
  // required string msg = 7;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required .jukey.prot.NetStream stream = 4;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // required uint32 user_type = 2;
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  uint32_t user_type() const;
  void set_user_type(uint32_t value);
  private:
  uint32_t _internal_user_type() const;
  void _internal_set_user_type(uint32_t value);
  public:

  // required uint32 user_id = 3;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  uint32_t user_id() const;
  void set_user_id(uint32_t value);
  private:
  uint32_t _internal_user_id() const;
  void _internal_set_user_id(uint32_t value);
  public:

  // required uint32 channel_id = 5;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint32_t channel_id() const;
  void set_channel_id(uint32_t value);
  private:
  uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(uint32_t value);
  public:

  // required uint32 result = 6;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.LogoutRecvChannelRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::jukey::prot::NetStream* stream_;
    uint32_t app_id_;
    uint32_t user_type_;
    uint32_t user_id_;
    uint32_t channel_id_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// -------------------------------------------------------------------

class NegotiateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.NegotiateReq) */ {
 public:
  inline NegotiateReq() : NegotiateReq(nullptr) {}
  ~NegotiateReq() override;
  explicit PROTOBUF_CONSTEXPR NegotiateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NegotiateReq(const NegotiateReq& from);
  NegotiateReq(NegotiateReq&& from) noexcept
    : NegotiateReq() {
    *this = ::std::move(from);
  }

  inline NegotiateReq& operator=(const NegotiateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline NegotiateReq& operator=(NegotiateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NegotiateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const NegotiateReq* internal_default_instance() {
    return reinterpret_cast<const NegotiateReq*>(
               &_NegotiateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NegotiateReq& a, NegotiateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(NegotiateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NegotiateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NegotiateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NegotiateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NegotiateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NegotiateReq& from) {
    NegotiateReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NegotiateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.NegotiateReq";
  }
  protected:
  explicit NegotiateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapsFieldNumber = 3,
    kStreamFieldNumber = 1,
    kChannelIdFieldNumber = 2,
  };
  // repeated string caps = 3;
  int caps_size() const;
  private:
  int _internal_caps_size() const;
  public:
  void clear_caps();
  const std::string& caps(int index) const;
  std::string* mutable_caps(int index);
  void set_caps(int index, const std::string& value);
  void set_caps(int index, std::string&& value);
  void set_caps(int index, const char* value);
  void set_caps(int index, const char* value, size_t size);
  std::string* add_caps();
  void add_caps(const std::string& value);
  void add_caps(std::string&& value);
  void add_caps(const char* value);
  void add_caps(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& caps() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_caps();
  private:
  const std::string& _internal_caps(int index) const;
  std::string* _internal_add_caps();
  public:

  // required .jukey.prot.NetStream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 channel_id = 2;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint32_t channel_id() const;
  void set_channel_id(uint32_t value);
  private:
  uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.NegotiateReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> caps_;
    ::jukey::prot::NetStream* stream_;
    uint32_t channel_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// -------------------------------------------------------------------

class NegotiateRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.NegotiateRsp) */ {
 public:
  inline NegotiateRsp() : NegotiateRsp(nullptr) {}
  ~NegotiateRsp() override;
  explicit PROTOBUF_CONSTEXPR NegotiateRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NegotiateRsp(const NegotiateRsp& from);
  NegotiateRsp(NegotiateRsp&& from) noexcept
    : NegotiateRsp() {
    *this = ::std::move(from);
  }

  inline NegotiateRsp& operator=(const NegotiateRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline NegotiateRsp& operator=(NegotiateRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NegotiateRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const NegotiateRsp* internal_default_instance() {
    return reinterpret_cast<const NegotiateRsp*>(
               &_NegotiateRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(NegotiateRsp& a, NegotiateRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(NegotiateRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NegotiateRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NegotiateRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NegotiateRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NegotiateRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NegotiateRsp& from) {
    NegotiateRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NegotiateRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.NegotiateRsp";
  }
  protected:
  explicit NegotiateRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapFieldNumber = 3,
    kMsgFieldNumber = 5,
    kStreamFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kResultFieldNumber = 4,
  };
  // required string cap = 3;
  bool has_cap() const;
  private:
  bool _internal_has_cap() const;
  public:
  void clear_cap();
  const std::string& cap() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cap(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cap();
  PROTOBUF_NODISCARD std::string* release_cap();
  void set_allocated_cap(std::string* cap);
  private:
  const std::string& _internal_cap() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cap(const std::string& value);
  std::string* _internal_mutable_cap();
  public:

  // required string msg = 5;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required .jukey.prot.NetStream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 channel_id = 2;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint32_t channel_id() const;
  void set_channel_id(uint32_t value);
  private:
  uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(uint32_t value);
  public:

  // required uint32 result = 4;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.NegotiateRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cap_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::jukey::prot::NetStream* stream_;
    uint32_t channel_id_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// -------------------------------------------------------------------

class StartSendStreamNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.StartSendStreamNotify) */ {
 public:
  inline StartSendStreamNotify() : StartSendStreamNotify(nullptr) {}
  ~StartSendStreamNotify() override;
  explicit PROTOBUF_CONSTEXPR StartSendStreamNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartSendStreamNotify(const StartSendStreamNotify& from);
  StartSendStreamNotify(StartSendStreamNotify&& from) noexcept
    : StartSendStreamNotify() {
    *this = ::std::move(from);
  }

  inline StartSendStreamNotify& operator=(const StartSendStreamNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartSendStreamNotify& operator=(StartSendStreamNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartSendStreamNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartSendStreamNotify* internal_default_instance() {
    return reinterpret_cast<const StartSendStreamNotify*>(
               &_StartSendStreamNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StartSendStreamNotify& a, StartSendStreamNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(StartSendStreamNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartSendStreamNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartSendStreamNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartSendStreamNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartSendStreamNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartSendStreamNotify& from) {
    StartSendStreamNotify::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartSendStreamNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.StartSendStreamNotify";
  }
  protected:
  explicit StartSendStreamNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 1,
    kChannelIdFieldNumber = 2,
  };
  // required .jukey.prot.NetStream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 channel_id = 2;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint32_t channel_id() const;
  void set_channel_id(uint32_t value);
  private:
  uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.StartSendStreamNotify)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::jukey::prot::NetStream* stream_;
    uint32_t channel_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// -------------------------------------------------------------------

class StartSendStreamAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.StartSendStreamAck) */ {
 public:
  inline StartSendStreamAck() : StartSendStreamAck(nullptr) {}
  ~StartSendStreamAck() override;
  explicit PROTOBUF_CONSTEXPR StartSendStreamAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartSendStreamAck(const StartSendStreamAck& from);
  StartSendStreamAck(StartSendStreamAck&& from) noexcept
    : StartSendStreamAck() {
    *this = ::std::move(from);
  }

  inline StartSendStreamAck& operator=(const StartSendStreamAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartSendStreamAck& operator=(StartSendStreamAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartSendStreamAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartSendStreamAck* internal_default_instance() {
    return reinterpret_cast<const StartSendStreamAck*>(
               &_StartSendStreamAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StartSendStreamAck& a, StartSendStreamAck& b) {
    a.Swap(&b);
  }
  inline void Swap(StartSendStreamAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartSendStreamAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartSendStreamAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartSendStreamAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartSendStreamAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartSendStreamAck& from) {
    StartSendStreamAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartSendStreamAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.StartSendStreamAck";
  }
  protected:
  explicit StartSendStreamAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 4,
    kStreamFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kResultFieldNumber = 3,
  };
  // required string msg = 4;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required .jukey.prot.NetStream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 channel_id = 2;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint32_t channel_id() const;
  void set_channel_id(uint32_t value);
  private:
  uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(uint32_t value);
  public:

  // required uint32 result = 3;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.StartSendStreamAck)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::jukey::prot::NetStream* stream_;
    uint32_t channel_id_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// -------------------------------------------------------------------

class StopSendStreamNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.StopSendStreamNotify) */ {
 public:
  inline StopSendStreamNotify() : StopSendStreamNotify(nullptr) {}
  ~StopSendStreamNotify() override;
  explicit PROTOBUF_CONSTEXPR StopSendStreamNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopSendStreamNotify(const StopSendStreamNotify& from);
  StopSendStreamNotify(StopSendStreamNotify&& from) noexcept
    : StopSendStreamNotify() {
    *this = ::std::move(from);
  }

  inline StopSendStreamNotify& operator=(const StopSendStreamNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopSendStreamNotify& operator=(StopSendStreamNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopSendStreamNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopSendStreamNotify* internal_default_instance() {
    return reinterpret_cast<const StopSendStreamNotify*>(
               &_StopSendStreamNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StopSendStreamNotify& a, StopSendStreamNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(StopSendStreamNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopSendStreamNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopSendStreamNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopSendStreamNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopSendStreamNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopSendStreamNotify& from) {
    StopSendStreamNotify::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopSendStreamNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.StopSendStreamNotify";
  }
  protected:
  explicit StopSendStreamNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 1,
    kChannelIdFieldNumber = 2,
  };
  // required .jukey.prot.NetStream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 channel_id = 2;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint32_t channel_id() const;
  void set_channel_id(uint32_t value);
  private:
  uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.StopSendStreamNotify)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::jukey::prot::NetStream* stream_;
    uint32_t channel_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// -------------------------------------------------------------------

class StopSendStreamAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.StopSendStreamAck) */ {
 public:
  inline StopSendStreamAck() : StopSendStreamAck(nullptr) {}
  ~StopSendStreamAck() override;
  explicit PROTOBUF_CONSTEXPR StopSendStreamAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopSendStreamAck(const StopSendStreamAck& from);
  StopSendStreamAck(StopSendStreamAck&& from) noexcept
    : StopSendStreamAck() {
    *this = ::std::move(from);
  }

  inline StopSendStreamAck& operator=(const StopSendStreamAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopSendStreamAck& operator=(StopSendStreamAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopSendStreamAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopSendStreamAck* internal_default_instance() {
    return reinterpret_cast<const StopSendStreamAck*>(
               &_StopSendStreamAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StopSendStreamAck& a, StopSendStreamAck& b) {
    a.Swap(&b);
  }
  inline void Swap(StopSendStreamAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopSendStreamAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopSendStreamAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopSendStreamAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopSendStreamAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopSendStreamAck& from) {
    StopSendStreamAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopSendStreamAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.StopSendStreamAck";
  }
  protected:
  explicit StopSendStreamAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 4,
    kStreamFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kResultFieldNumber = 3,
  };
  // required string msg = 4;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required .jukey.prot.NetStream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 channel_id = 2;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint32_t channel_id() const;
  void set_channel_id(uint32_t value);
  private:
  uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(uint32_t value);
  public:

  // required uint32 result = 3;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.StopSendStreamAck)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::jukey::prot::NetStream* stream_;
    uint32_t channel_id_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// -------------------------------------------------------------------

class PauseRecvStreamReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.PauseRecvStreamReq) */ {
 public:
  inline PauseRecvStreamReq() : PauseRecvStreamReq(nullptr) {}
  ~PauseRecvStreamReq() override;
  explicit PROTOBUF_CONSTEXPR PauseRecvStreamReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PauseRecvStreamReq(const PauseRecvStreamReq& from);
  PauseRecvStreamReq(PauseRecvStreamReq&& from) noexcept
    : PauseRecvStreamReq() {
    *this = ::std::move(from);
  }

  inline PauseRecvStreamReq& operator=(const PauseRecvStreamReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PauseRecvStreamReq& operator=(PauseRecvStreamReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PauseRecvStreamReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PauseRecvStreamReq* internal_default_instance() {
    return reinterpret_cast<const PauseRecvStreamReq*>(
               &_PauseRecvStreamReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PauseRecvStreamReq& a, PauseRecvStreamReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PauseRecvStreamReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PauseRecvStreamReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PauseRecvStreamReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PauseRecvStreamReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PauseRecvStreamReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PauseRecvStreamReq& from) {
    PauseRecvStreamReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PauseRecvStreamReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.PauseRecvStreamReq";
  }
  protected:
  explicit PauseRecvStreamReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 1,
    kChannelIdFieldNumber = 2,
  };
  // required .jukey.prot.NetStream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 channel_id = 2;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint32_t channel_id() const;
  void set_channel_id(uint32_t value);
  private:
  uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.PauseRecvStreamReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::jukey::prot::NetStream* stream_;
    uint32_t channel_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// -------------------------------------------------------------------

class PauseRecvStreamRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.PauseRecvStreamRsp) */ {
 public:
  inline PauseRecvStreamRsp() : PauseRecvStreamRsp(nullptr) {}
  ~PauseRecvStreamRsp() override;
  explicit PROTOBUF_CONSTEXPR PauseRecvStreamRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PauseRecvStreamRsp(const PauseRecvStreamRsp& from);
  PauseRecvStreamRsp(PauseRecvStreamRsp&& from) noexcept
    : PauseRecvStreamRsp() {
    *this = ::std::move(from);
  }

  inline PauseRecvStreamRsp& operator=(const PauseRecvStreamRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline PauseRecvStreamRsp& operator=(PauseRecvStreamRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PauseRecvStreamRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const PauseRecvStreamRsp* internal_default_instance() {
    return reinterpret_cast<const PauseRecvStreamRsp*>(
               &_PauseRecvStreamRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PauseRecvStreamRsp& a, PauseRecvStreamRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(PauseRecvStreamRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PauseRecvStreamRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PauseRecvStreamRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PauseRecvStreamRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PauseRecvStreamRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PauseRecvStreamRsp& from) {
    PauseRecvStreamRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PauseRecvStreamRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.PauseRecvStreamRsp";
  }
  protected:
  explicit PauseRecvStreamRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 4,
    kStreamFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kResultFieldNumber = 3,
  };
  // required string msg = 4;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required .jukey.prot.NetStream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 channel_id = 2;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint32_t channel_id() const;
  void set_channel_id(uint32_t value);
  private:
  uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(uint32_t value);
  public:

  // required uint32 result = 3;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.PauseRecvStreamRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::jukey::prot::NetStream* stream_;
    uint32_t channel_id_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// -------------------------------------------------------------------

class ResumeRecvStreamReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.ResumeRecvStreamReq) */ {
 public:
  inline ResumeRecvStreamReq() : ResumeRecvStreamReq(nullptr) {}
  ~ResumeRecvStreamReq() override;
  explicit PROTOBUF_CONSTEXPR ResumeRecvStreamReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResumeRecvStreamReq(const ResumeRecvStreamReq& from);
  ResumeRecvStreamReq(ResumeRecvStreamReq&& from) noexcept
    : ResumeRecvStreamReq() {
    *this = ::std::move(from);
  }

  inline ResumeRecvStreamReq& operator=(const ResumeRecvStreamReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResumeRecvStreamReq& operator=(ResumeRecvStreamReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResumeRecvStreamReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResumeRecvStreamReq* internal_default_instance() {
    return reinterpret_cast<const ResumeRecvStreamReq*>(
               &_ResumeRecvStreamReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ResumeRecvStreamReq& a, ResumeRecvStreamReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ResumeRecvStreamReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResumeRecvStreamReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResumeRecvStreamReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResumeRecvStreamReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResumeRecvStreamReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResumeRecvStreamReq& from) {
    ResumeRecvStreamReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResumeRecvStreamReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.ResumeRecvStreamReq";
  }
  protected:
  explicit ResumeRecvStreamReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 1,
    kChannelIdFieldNumber = 2,
  };
  // required .jukey.prot.NetStream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 channel_id = 2;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint32_t channel_id() const;
  void set_channel_id(uint32_t value);
  private:
  uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.ResumeRecvStreamReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::jukey::prot::NetStream* stream_;
    uint32_t channel_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// -------------------------------------------------------------------

class ResumeRecvStreamRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:jukey.prot.ResumeRecvStreamRsp) */ {
 public:
  inline ResumeRecvStreamRsp() : ResumeRecvStreamRsp(nullptr) {}
  ~ResumeRecvStreamRsp() override;
  explicit PROTOBUF_CONSTEXPR ResumeRecvStreamRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResumeRecvStreamRsp(const ResumeRecvStreamRsp& from);
  ResumeRecvStreamRsp(ResumeRecvStreamRsp&& from) noexcept
    : ResumeRecvStreamRsp() {
    *this = ::std::move(from);
  }

  inline ResumeRecvStreamRsp& operator=(const ResumeRecvStreamRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResumeRecvStreamRsp& operator=(ResumeRecvStreamRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResumeRecvStreamRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResumeRecvStreamRsp* internal_default_instance() {
    return reinterpret_cast<const ResumeRecvStreamRsp*>(
               &_ResumeRecvStreamRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ResumeRecvStreamRsp& a, ResumeRecvStreamRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(ResumeRecvStreamRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResumeRecvStreamRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResumeRecvStreamRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResumeRecvStreamRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResumeRecvStreamRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResumeRecvStreamRsp& from) {
    ResumeRecvStreamRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResumeRecvStreamRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "jukey.prot.ResumeRecvStreamRsp";
  }
  protected:
  explicit ResumeRecvStreamRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 4,
    kStreamFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kResultFieldNumber = 3,
  };
  // required string msg = 4;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required .jukey.prot.NetStream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::jukey::prot::NetStream& stream() const;
  PROTOBUF_NODISCARD ::jukey::prot::NetStream* release_stream();
  ::jukey::prot::NetStream* mutable_stream();
  void set_allocated_stream(::jukey::prot::NetStream* stream);
  private:
  const ::jukey::prot::NetStream& _internal_stream() const;
  ::jukey::prot::NetStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::jukey::prot::NetStream* stream);
  ::jukey::prot::NetStream* unsafe_arena_release_stream();

  // required uint32 channel_id = 2;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint32_t channel_id() const;
  void set_channel_id(uint32_t value);
  private:
  uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(uint32_t value);
  public:

  // required uint32 result = 3;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:jukey.prot.ResumeRecvStreamRsp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::jukey::prot::NetStream* stream_;
    uint32_t channel_id_;
    uint32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transport_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LoginSendChannelReq

// required uint32 app_id = 1;
inline bool LoginSendChannelReq::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LoginSendChannelReq::has_app_id() const {
  return _internal_has_app_id();
}
inline void LoginSendChannelReq::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LoginSendChannelReq::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t LoginSendChannelReq::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelReq.app_id)
  return _internal_app_id();
}
inline void LoginSendChannelReq::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_id_ = value;
}
inline void LoginSendChannelReq::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelReq.app_id)
}

// required uint32 user_type = 2;
inline bool LoginSendChannelReq::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LoginSendChannelReq::has_user_type() const {
  return _internal_has_user_type();
}
inline void LoginSendChannelReq::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t LoginSendChannelReq::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t LoginSendChannelReq::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelReq.user_type)
  return _internal_user_type();
}
inline void LoginSendChannelReq::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_type_ = value;
}
inline void LoginSendChannelReq::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelReq.user_type)
}

// required uint32 user_id = 3;
inline bool LoginSendChannelReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LoginSendChannelReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void LoginSendChannelReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t LoginSendChannelReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t LoginSendChannelReq::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelReq.user_id)
  return _internal_user_id();
}
inline void LoginSendChannelReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_id_ = value;
}
inline void LoginSendChannelReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelReq.user_id)
}

// required .jukey.prot.NetStream stream = 4;
inline bool LoginSendChannelReq::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool LoginSendChannelReq::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& LoginSendChannelReq::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& LoginSendChannelReq::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelReq.stream)
  return _internal_stream();
}
inline void LoginSendChannelReq::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.LoginSendChannelReq.stream)
}
inline ::jukey::prot::NetStream* LoginSendChannelReq::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* LoginSendChannelReq::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.LoginSendChannelReq.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* LoginSendChannelReq::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* LoginSendChannelReq::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LoginSendChannelReq.stream)
  return _msg;
}
inline void LoginSendChannelReq::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LoginSendChannelReq.stream)
}

// required string token = 5;
inline bool LoginSendChannelReq::_internal_has_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginSendChannelReq::has_token() const {
  return _internal_has_token();
}
inline void LoginSendChannelReq::clear_token() {
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginSendChannelReq::token() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginSendChannelReq::set_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelReq.token)
}
inline std::string* LoginSendChannelReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LoginSendChannelReq.token)
  return _s;
}
inline const std::string& LoginSendChannelReq::_internal_token() const {
  return _impl_.token_.Get();
}
inline void LoginSendChannelReq::_internal_set_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginSendChannelReq::_internal_mutable_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginSendChannelReq::release_token() {
  // @@protoc_insertion_point(field_release:jukey.prot.LoginSendChannelReq.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginSendChannelReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LoginSendChannelReq.token)
}

// -------------------------------------------------------------------

// LoginSendChannelRsp

// required uint32 app_id = 1;
inline bool LoginSendChannelRsp::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LoginSendChannelRsp::has_app_id() const {
  return _internal_has_app_id();
}
inline void LoginSendChannelRsp::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LoginSendChannelRsp::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t LoginSendChannelRsp::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelRsp.app_id)
  return _internal_app_id();
}
inline void LoginSendChannelRsp::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_id_ = value;
}
inline void LoginSendChannelRsp::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelRsp.app_id)
}

// required uint32 user_type = 2;
inline bool LoginSendChannelRsp::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LoginSendChannelRsp::has_user_type() const {
  return _internal_has_user_type();
}
inline void LoginSendChannelRsp::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t LoginSendChannelRsp::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t LoginSendChannelRsp::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelRsp.user_type)
  return _internal_user_type();
}
inline void LoginSendChannelRsp::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_type_ = value;
}
inline void LoginSendChannelRsp::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelRsp.user_type)
}

// required uint32 user_id = 3;
inline bool LoginSendChannelRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LoginSendChannelRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void LoginSendChannelRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t LoginSendChannelRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t LoginSendChannelRsp::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelRsp.user_id)
  return _internal_user_id();
}
inline void LoginSendChannelRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_id_ = value;
}
inline void LoginSendChannelRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelRsp.user_id)
}

// required .jukey.prot.NetStream stream = 4;
inline bool LoginSendChannelRsp::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool LoginSendChannelRsp::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& LoginSendChannelRsp::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& LoginSendChannelRsp::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelRsp.stream)
  return _internal_stream();
}
inline void LoginSendChannelRsp::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.LoginSendChannelRsp.stream)
}
inline ::jukey::prot::NetStream* LoginSendChannelRsp::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* LoginSendChannelRsp::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.LoginSendChannelRsp.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* LoginSendChannelRsp::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* LoginSendChannelRsp::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LoginSendChannelRsp.stream)
  return _msg;
}
inline void LoginSendChannelRsp::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LoginSendChannelRsp.stream)
}

// required uint32 channel_id = 5;
inline bool LoginSendChannelRsp::_internal_has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LoginSendChannelRsp::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void LoginSendChannelRsp::clear_channel_id() {
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t LoginSendChannelRsp::_internal_channel_id() const {
  return _impl_.channel_id_;
}
inline uint32_t LoginSendChannelRsp::channel_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelRsp.channel_id)
  return _internal_channel_id();
}
inline void LoginSendChannelRsp::_internal_set_channel_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.channel_id_ = value;
}
inline void LoginSendChannelRsp::set_channel_id(uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelRsp.channel_id)
}

// required uint32 result = 6;
inline bool LoginSendChannelRsp::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LoginSendChannelRsp::has_result() const {
  return _internal_has_result();
}
inline void LoginSendChannelRsp::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t LoginSendChannelRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t LoginSendChannelRsp::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelRsp.result)
  return _internal_result();
}
inline void LoginSendChannelRsp::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.result_ = value;
}
inline void LoginSendChannelRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelRsp.result)
}

// required string msg = 7;
inline bool LoginSendChannelRsp::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginSendChannelRsp::has_msg() const {
  return _internal_has_msg();
}
inline void LoginSendChannelRsp::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginSendChannelRsp::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginSendChannelRsp.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginSendChannelRsp::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.LoginSendChannelRsp.msg)
}
inline std::string* LoginSendChannelRsp::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LoginSendChannelRsp.msg)
  return _s;
}
inline const std::string& LoginSendChannelRsp::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void LoginSendChannelRsp::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginSendChannelRsp::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginSendChannelRsp::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.LoginSendChannelRsp.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginSendChannelRsp::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LoginSendChannelRsp.msg)
}

// -------------------------------------------------------------------

// LogoutSendChannelReq

// required uint32 app_id = 1;
inline bool LogoutSendChannelReq::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LogoutSendChannelReq::has_app_id() const {
  return _internal_has_app_id();
}
inline void LogoutSendChannelReq::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LogoutSendChannelReq::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t LogoutSendChannelReq::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutSendChannelReq.app_id)
  return _internal_app_id();
}
inline void LogoutSendChannelReq::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_id_ = value;
}
inline void LogoutSendChannelReq::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutSendChannelReq.app_id)
}

// required uint32 user_type = 2;
inline bool LogoutSendChannelReq::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LogoutSendChannelReq::has_user_type() const {
  return _internal_has_user_type();
}
inline void LogoutSendChannelReq::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t LogoutSendChannelReq::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t LogoutSendChannelReq::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutSendChannelReq.user_type)
  return _internal_user_type();
}
inline void LogoutSendChannelReq::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_type_ = value;
}
inline void LogoutSendChannelReq::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutSendChannelReq.user_type)
}

// required uint32 user_id = 3;
inline bool LogoutSendChannelReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LogoutSendChannelReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void LogoutSendChannelReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t LogoutSendChannelReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t LogoutSendChannelReq::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutSendChannelReq.user_id)
  return _internal_user_id();
}
inline void LogoutSendChannelReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_id_ = value;
}
inline void LogoutSendChannelReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutSendChannelReq.user_id)
}

// required .jukey.prot.NetStream stream = 4;
inline bool LogoutSendChannelReq::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool LogoutSendChannelReq::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& LogoutSendChannelReq::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& LogoutSendChannelReq::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutSendChannelReq.stream)
  return _internal_stream();
}
inline void LogoutSendChannelReq::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.LogoutSendChannelReq.stream)
}
inline ::jukey::prot::NetStream* LogoutSendChannelReq::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* LogoutSendChannelReq::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.LogoutSendChannelReq.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* LogoutSendChannelReq::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* LogoutSendChannelReq::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LogoutSendChannelReq.stream)
  return _msg;
}
inline void LogoutSendChannelReq::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LogoutSendChannelReq.stream)
}

// required uint32 channel_id = 5;
inline bool LogoutSendChannelReq::_internal_has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LogoutSendChannelReq::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void LogoutSendChannelReq::clear_channel_id() {
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t LogoutSendChannelReq::_internal_channel_id() const {
  return _impl_.channel_id_;
}
inline uint32_t LogoutSendChannelReq::channel_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutSendChannelReq.channel_id)
  return _internal_channel_id();
}
inline void LogoutSendChannelReq::_internal_set_channel_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.channel_id_ = value;
}
inline void LogoutSendChannelReq::set_channel_id(uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutSendChannelReq.channel_id)
}

// required string token = 6;
inline bool LogoutSendChannelReq::_internal_has_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LogoutSendChannelReq::has_token() const {
  return _internal_has_token();
}
inline void LogoutSendChannelReq::clear_token() {
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LogoutSendChannelReq::token() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutSendChannelReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogoutSendChannelReq::set_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutSendChannelReq.token)
}
inline std::string* LogoutSendChannelReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LogoutSendChannelReq.token)
  return _s;
}
inline const std::string& LogoutSendChannelReq::_internal_token() const {
  return _impl_.token_.Get();
}
inline void LogoutSendChannelReq::_internal_set_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* LogoutSendChannelReq::_internal_mutable_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* LogoutSendChannelReq::release_token() {
  // @@protoc_insertion_point(field_release:jukey.prot.LogoutSendChannelReq.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LogoutSendChannelReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LogoutSendChannelReq.token)
}

// -------------------------------------------------------------------

// LogoutSendChannelRsp

// required uint32 app_id = 1;
inline bool LogoutSendChannelRsp::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LogoutSendChannelRsp::has_app_id() const {
  return _internal_has_app_id();
}
inline void LogoutSendChannelRsp::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LogoutSendChannelRsp::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t LogoutSendChannelRsp::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutSendChannelRsp.app_id)
  return _internal_app_id();
}
inline void LogoutSendChannelRsp::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_id_ = value;
}
inline void LogoutSendChannelRsp::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutSendChannelRsp.app_id)
}

// required uint32 user_type = 2;
inline bool LogoutSendChannelRsp::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LogoutSendChannelRsp::has_user_type() const {
  return _internal_has_user_type();
}
inline void LogoutSendChannelRsp::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t LogoutSendChannelRsp::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t LogoutSendChannelRsp::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutSendChannelRsp.user_type)
  return _internal_user_type();
}
inline void LogoutSendChannelRsp::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_type_ = value;
}
inline void LogoutSendChannelRsp::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutSendChannelRsp.user_type)
}

// required uint32 user_id = 3;
inline bool LogoutSendChannelRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LogoutSendChannelRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void LogoutSendChannelRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t LogoutSendChannelRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t LogoutSendChannelRsp::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutSendChannelRsp.user_id)
  return _internal_user_id();
}
inline void LogoutSendChannelRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_id_ = value;
}
inline void LogoutSendChannelRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutSendChannelRsp.user_id)
}

// required .jukey.prot.NetStream stream = 4;
inline bool LogoutSendChannelRsp::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool LogoutSendChannelRsp::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& LogoutSendChannelRsp::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& LogoutSendChannelRsp::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutSendChannelRsp.stream)
  return _internal_stream();
}
inline void LogoutSendChannelRsp::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.LogoutSendChannelRsp.stream)
}
inline ::jukey::prot::NetStream* LogoutSendChannelRsp::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* LogoutSendChannelRsp::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.LogoutSendChannelRsp.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* LogoutSendChannelRsp::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* LogoutSendChannelRsp::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LogoutSendChannelRsp.stream)
  return _msg;
}
inline void LogoutSendChannelRsp::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LogoutSendChannelRsp.stream)
}

// required uint32 channel_id = 5;
inline bool LogoutSendChannelRsp::_internal_has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LogoutSendChannelRsp::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void LogoutSendChannelRsp::clear_channel_id() {
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t LogoutSendChannelRsp::_internal_channel_id() const {
  return _impl_.channel_id_;
}
inline uint32_t LogoutSendChannelRsp::channel_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutSendChannelRsp.channel_id)
  return _internal_channel_id();
}
inline void LogoutSendChannelRsp::_internal_set_channel_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.channel_id_ = value;
}
inline void LogoutSendChannelRsp::set_channel_id(uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutSendChannelRsp.channel_id)
}

// required uint32 result = 6;
inline bool LogoutSendChannelRsp::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LogoutSendChannelRsp::has_result() const {
  return _internal_has_result();
}
inline void LogoutSendChannelRsp::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t LogoutSendChannelRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t LogoutSendChannelRsp::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutSendChannelRsp.result)
  return _internal_result();
}
inline void LogoutSendChannelRsp::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.result_ = value;
}
inline void LogoutSendChannelRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutSendChannelRsp.result)
}

// required string msg = 7;
inline bool LogoutSendChannelRsp::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LogoutSendChannelRsp::has_msg() const {
  return _internal_has_msg();
}
inline void LogoutSendChannelRsp::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LogoutSendChannelRsp::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutSendChannelRsp.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogoutSendChannelRsp::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutSendChannelRsp.msg)
}
inline std::string* LogoutSendChannelRsp::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LogoutSendChannelRsp.msg)
  return _s;
}
inline const std::string& LogoutSendChannelRsp::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void LogoutSendChannelRsp::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* LogoutSendChannelRsp::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* LogoutSendChannelRsp::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.LogoutSendChannelRsp.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LogoutSendChannelRsp::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LogoutSendChannelRsp.msg)
}

// -------------------------------------------------------------------

// LoginRecvChannelReq

// required uint32 app_id = 1;
inline bool LoginRecvChannelReq::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LoginRecvChannelReq::has_app_id() const {
  return _internal_has_app_id();
}
inline void LoginRecvChannelReq::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LoginRecvChannelReq::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t LoginRecvChannelReq::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginRecvChannelReq.app_id)
  return _internal_app_id();
}
inline void LoginRecvChannelReq::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_id_ = value;
}
inline void LoginRecvChannelReq::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginRecvChannelReq.app_id)
}

// required uint32 user_type = 2;
inline bool LoginRecvChannelReq::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LoginRecvChannelReq::has_user_type() const {
  return _internal_has_user_type();
}
inline void LoginRecvChannelReq::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t LoginRecvChannelReq::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t LoginRecvChannelReq::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginRecvChannelReq.user_type)
  return _internal_user_type();
}
inline void LoginRecvChannelReq::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_type_ = value;
}
inline void LoginRecvChannelReq::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginRecvChannelReq.user_type)
}

// required uint32 user_id = 3;
inline bool LoginRecvChannelReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LoginRecvChannelReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void LoginRecvChannelReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t LoginRecvChannelReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t LoginRecvChannelReq::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginRecvChannelReq.user_id)
  return _internal_user_id();
}
inline void LoginRecvChannelReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_id_ = value;
}
inline void LoginRecvChannelReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginRecvChannelReq.user_id)
}

// required .jukey.prot.NetStream stream = 4;
inline bool LoginRecvChannelReq::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool LoginRecvChannelReq::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& LoginRecvChannelReq::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& LoginRecvChannelReq::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginRecvChannelReq.stream)
  return _internal_stream();
}
inline void LoginRecvChannelReq::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.LoginRecvChannelReq.stream)
}
inline ::jukey::prot::NetStream* LoginRecvChannelReq::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* LoginRecvChannelReq::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.LoginRecvChannelReq.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* LoginRecvChannelReq::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* LoginRecvChannelReq::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LoginRecvChannelReq.stream)
  return _msg;
}
inline void LoginRecvChannelReq::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LoginRecvChannelReq.stream)
}

// required string token = 5;
inline bool LoginRecvChannelReq::_internal_has_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginRecvChannelReq::has_token() const {
  return _internal_has_token();
}
inline void LoginRecvChannelReq::clear_token() {
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginRecvChannelReq::token() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginRecvChannelReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRecvChannelReq::set_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.LoginRecvChannelReq.token)
}
inline std::string* LoginRecvChannelReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LoginRecvChannelReq.token)
  return _s;
}
inline const std::string& LoginRecvChannelReq::_internal_token() const {
  return _impl_.token_.Get();
}
inline void LoginRecvChannelReq::_internal_set_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRecvChannelReq::_internal_mutable_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRecvChannelReq::release_token() {
  // @@protoc_insertion_point(field_release:jukey.prot.LoginRecvChannelReq.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginRecvChannelReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LoginRecvChannelReq.token)
}

// -------------------------------------------------------------------

// LoginRecvChannelRsp

// required uint32 app_id = 1;
inline bool LoginRecvChannelRsp::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LoginRecvChannelRsp::has_app_id() const {
  return _internal_has_app_id();
}
inline void LoginRecvChannelRsp::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LoginRecvChannelRsp::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t LoginRecvChannelRsp::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginRecvChannelRsp.app_id)
  return _internal_app_id();
}
inline void LoginRecvChannelRsp::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_id_ = value;
}
inline void LoginRecvChannelRsp::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginRecvChannelRsp.app_id)
}

// required uint32 user_type = 2;
inline bool LoginRecvChannelRsp::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LoginRecvChannelRsp::has_user_type() const {
  return _internal_has_user_type();
}
inline void LoginRecvChannelRsp::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t LoginRecvChannelRsp::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t LoginRecvChannelRsp::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginRecvChannelRsp.user_type)
  return _internal_user_type();
}
inline void LoginRecvChannelRsp::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_type_ = value;
}
inline void LoginRecvChannelRsp::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginRecvChannelRsp.user_type)
}

// required uint32 user_id = 3;
inline bool LoginRecvChannelRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LoginRecvChannelRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void LoginRecvChannelRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t LoginRecvChannelRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t LoginRecvChannelRsp::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginRecvChannelRsp.user_id)
  return _internal_user_id();
}
inline void LoginRecvChannelRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_id_ = value;
}
inline void LoginRecvChannelRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginRecvChannelRsp.user_id)
}

// required .jukey.prot.NetStream stream = 4;
inline bool LoginRecvChannelRsp::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool LoginRecvChannelRsp::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& LoginRecvChannelRsp::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& LoginRecvChannelRsp::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginRecvChannelRsp.stream)
  return _internal_stream();
}
inline void LoginRecvChannelRsp::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.LoginRecvChannelRsp.stream)
}
inline ::jukey::prot::NetStream* LoginRecvChannelRsp::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* LoginRecvChannelRsp::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.LoginRecvChannelRsp.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* LoginRecvChannelRsp::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* LoginRecvChannelRsp::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LoginRecvChannelRsp.stream)
  return _msg;
}
inline void LoginRecvChannelRsp::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LoginRecvChannelRsp.stream)
}

// required uint32 channel_id = 5;
inline bool LoginRecvChannelRsp::_internal_has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LoginRecvChannelRsp::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void LoginRecvChannelRsp::clear_channel_id() {
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t LoginRecvChannelRsp::_internal_channel_id() const {
  return _impl_.channel_id_;
}
inline uint32_t LoginRecvChannelRsp::channel_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginRecvChannelRsp.channel_id)
  return _internal_channel_id();
}
inline void LoginRecvChannelRsp::_internal_set_channel_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.channel_id_ = value;
}
inline void LoginRecvChannelRsp::set_channel_id(uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginRecvChannelRsp.channel_id)
}

// required uint32 result = 6;
inline bool LoginRecvChannelRsp::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LoginRecvChannelRsp::has_result() const {
  return _internal_has_result();
}
inline void LoginRecvChannelRsp::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t LoginRecvChannelRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t LoginRecvChannelRsp::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginRecvChannelRsp.result)
  return _internal_result();
}
inline void LoginRecvChannelRsp::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.result_ = value;
}
inline void LoginRecvChannelRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LoginRecvChannelRsp.result)
}

// required string msg = 7;
inline bool LoginRecvChannelRsp::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginRecvChannelRsp::has_msg() const {
  return _internal_has_msg();
}
inline void LoginRecvChannelRsp::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginRecvChannelRsp::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LoginRecvChannelRsp.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRecvChannelRsp::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.LoginRecvChannelRsp.msg)
}
inline std::string* LoginRecvChannelRsp::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LoginRecvChannelRsp.msg)
  return _s;
}
inline const std::string& LoginRecvChannelRsp::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void LoginRecvChannelRsp::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRecvChannelRsp::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRecvChannelRsp::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.LoginRecvChannelRsp.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginRecvChannelRsp::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LoginRecvChannelRsp.msg)
}

// -------------------------------------------------------------------

// LogoutRecvChannelReq

// required uint32 app_id = 1;
inline bool LogoutRecvChannelReq::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LogoutRecvChannelReq::has_app_id() const {
  return _internal_has_app_id();
}
inline void LogoutRecvChannelReq::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LogoutRecvChannelReq::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t LogoutRecvChannelReq::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutRecvChannelReq.app_id)
  return _internal_app_id();
}
inline void LogoutRecvChannelReq::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_id_ = value;
}
inline void LogoutRecvChannelReq::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutRecvChannelReq.app_id)
}

// required uint32 user_type = 2;
inline bool LogoutRecvChannelReq::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LogoutRecvChannelReq::has_user_type() const {
  return _internal_has_user_type();
}
inline void LogoutRecvChannelReq::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t LogoutRecvChannelReq::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t LogoutRecvChannelReq::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutRecvChannelReq.user_type)
  return _internal_user_type();
}
inline void LogoutRecvChannelReq::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_type_ = value;
}
inline void LogoutRecvChannelReq::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutRecvChannelReq.user_type)
}

// required uint32 user_id = 3;
inline bool LogoutRecvChannelReq::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LogoutRecvChannelReq::has_user_id() const {
  return _internal_has_user_id();
}
inline void LogoutRecvChannelReq::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t LogoutRecvChannelReq::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t LogoutRecvChannelReq::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutRecvChannelReq.user_id)
  return _internal_user_id();
}
inline void LogoutRecvChannelReq::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_id_ = value;
}
inline void LogoutRecvChannelReq::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutRecvChannelReq.user_id)
}

// required .jukey.prot.NetStream stream = 4;
inline bool LogoutRecvChannelReq::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool LogoutRecvChannelReq::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& LogoutRecvChannelReq::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& LogoutRecvChannelReq::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutRecvChannelReq.stream)
  return _internal_stream();
}
inline void LogoutRecvChannelReq::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.LogoutRecvChannelReq.stream)
}
inline ::jukey::prot::NetStream* LogoutRecvChannelReq::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* LogoutRecvChannelReq::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.LogoutRecvChannelReq.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* LogoutRecvChannelReq::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* LogoutRecvChannelReq::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LogoutRecvChannelReq.stream)
  return _msg;
}
inline void LogoutRecvChannelReq::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LogoutRecvChannelReq.stream)
}

// required uint32 channel_id = 5;
inline bool LogoutRecvChannelReq::_internal_has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LogoutRecvChannelReq::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void LogoutRecvChannelReq::clear_channel_id() {
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t LogoutRecvChannelReq::_internal_channel_id() const {
  return _impl_.channel_id_;
}
inline uint32_t LogoutRecvChannelReq::channel_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutRecvChannelReq.channel_id)
  return _internal_channel_id();
}
inline void LogoutRecvChannelReq::_internal_set_channel_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.channel_id_ = value;
}
inline void LogoutRecvChannelReq::set_channel_id(uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutRecvChannelReq.channel_id)
}

// required string token = 6;
inline bool LogoutRecvChannelReq::_internal_has_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LogoutRecvChannelReq::has_token() const {
  return _internal_has_token();
}
inline void LogoutRecvChannelReq::clear_token() {
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LogoutRecvChannelReq::token() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutRecvChannelReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogoutRecvChannelReq::set_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutRecvChannelReq.token)
}
inline std::string* LogoutRecvChannelReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LogoutRecvChannelReq.token)
  return _s;
}
inline const std::string& LogoutRecvChannelReq::_internal_token() const {
  return _impl_.token_.Get();
}
inline void LogoutRecvChannelReq::_internal_set_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* LogoutRecvChannelReq::_internal_mutable_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* LogoutRecvChannelReq::release_token() {
  // @@protoc_insertion_point(field_release:jukey.prot.LogoutRecvChannelReq.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LogoutRecvChannelReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LogoutRecvChannelReq.token)
}

// -------------------------------------------------------------------

// LogoutRecvChannelRsp

// required uint32 app_id = 1;
inline bool LogoutRecvChannelRsp::_internal_has_app_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LogoutRecvChannelRsp::has_app_id() const {
  return _internal_has_app_id();
}
inline void LogoutRecvChannelRsp::clear_app_id() {
  _impl_.app_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LogoutRecvChannelRsp::_internal_app_id() const {
  return _impl_.app_id_;
}
inline uint32_t LogoutRecvChannelRsp::app_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutRecvChannelRsp.app_id)
  return _internal_app_id();
}
inline void LogoutRecvChannelRsp::_internal_set_app_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.app_id_ = value;
}
inline void LogoutRecvChannelRsp::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutRecvChannelRsp.app_id)
}

// required uint32 user_type = 2;
inline bool LogoutRecvChannelRsp::_internal_has_user_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LogoutRecvChannelRsp::has_user_type() const {
  return _internal_has_user_type();
}
inline void LogoutRecvChannelRsp::clear_user_type() {
  _impl_.user_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t LogoutRecvChannelRsp::_internal_user_type() const {
  return _impl_.user_type_;
}
inline uint32_t LogoutRecvChannelRsp::user_type() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutRecvChannelRsp.user_type)
  return _internal_user_type();
}
inline void LogoutRecvChannelRsp::_internal_set_user_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_type_ = value;
}
inline void LogoutRecvChannelRsp::set_user_type(uint32_t value) {
  _internal_set_user_type(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutRecvChannelRsp.user_type)
}

// required uint32 user_id = 3;
inline bool LogoutRecvChannelRsp::_internal_has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LogoutRecvChannelRsp::has_user_id() const {
  return _internal_has_user_id();
}
inline void LogoutRecvChannelRsp::clear_user_id() {
  _impl_.user_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t LogoutRecvChannelRsp::_internal_user_id() const {
  return _impl_.user_id_;
}
inline uint32_t LogoutRecvChannelRsp::user_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutRecvChannelRsp.user_id)
  return _internal_user_id();
}
inline void LogoutRecvChannelRsp::_internal_set_user_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.user_id_ = value;
}
inline void LogoutRecvChannelRsp::set_user_id(uint32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutRecvChannelRsp.user_id)
}

// required .jukey.prot.NetStream stream = 4;
inline bool LogoutRecvChannelRsp::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool LogoutRecvChannelRsp::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& LogoutRecvChannelRsp::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& LogoutRecvChannelRsp::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutRecvChannelRsp.stream)
  return _internal_stream();
}
inline void LogoutRecvChannelRsp::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.LogoutRecvChannelRsp.stream)
}
inline ::jukey::prot::NetStream* LogoutRecvChannelRsp::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* LogoutRecvChannelRsp::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.LogoutRecvChannelRsp.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* LogoutRecvChannelRsp::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* LogoutRecvChannelRsp::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LogoutRecvChannelRsp.stream)
  return _msg;
}
inline void LogoutRecvChannelRsp::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LogoutRecvChannelRsp.stream)
}

// required uint32 channel_id = 5;
inline bool LogoutRecvChannelRsp::_internal_has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LogoutRecvChannelRsp::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void LogoutRecvChannelRsp::clear_channel_id() {
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t LogoutRecvChannelRsp::_internal_channel_id() const {
  return _impl_.channel_id_;
}
inline uint32_t LogoutRecvChannelRsp::channel_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutRecvChannelRsp.channel_id)
  return _internal_channel_id();
}
inline void LogoutRecvChannelRsp::_internal_set_channel_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.channel_id_ = value;
}
inline void LogoutRecvChannelRsp::set_channel_id(uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutRecvChannelRsp.channel_id)
}

// required uint32 result = 6;
inline bool LogoutRecvChannelRsp::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LogoutRecvChannelRsp::has_result() const {
  return _internal_has_result();
}
inline void LogoutRecvChannelRsp::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t LogoutRecvChannelRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t LogoutRecvChannelRsp::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutRecvChannelRsp.result)
  return _internal_result();
}
inline void LogoutRecvChannelRsp::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.result_ = value;
}
inline void LogoutRecvChannelRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutRecvChannelRsp.result)
}

// required string msg = 7;
inline bool LogoutRecvChannelRsp::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LogoutRecvChannelRsp::has_msg() const {
  return _internal_has_msg();
}
inline void LogoutRecvChannelRsp::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LogoutRecvChannelRsp::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.LogoutRecvChannelRsp.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogoutRecvChannelRsp::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.LogoutRecvChannelRsp.msg)
}
inline std::string* LogoutRecvChannelRsp::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.LogoutRecvChannelRsp.msg)
  return _s;
}
inline const std::string& LogoutRecvChannelRsp::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void LogoutRecvChannelRsp::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* LogoutRecvChannelRsp::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* LogoutRecvChannelRsp::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.LogoutRecvChannelRsp.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LogoutRecvChannelRsp::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.LogoutRecvChannelRsp.msg)
}

// -------------------------------------------------------------------

// NegotiateReq

// required .jukey.prot.NetStream stream = 1;
inline bool NegotiateReq::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool NegotiateReq::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& NegotiateReq::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& NegotiateReq::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.NegotiateReq.stream)
  return _internal_stream();
}
inline void NegotiateReq::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.NegotiateReq.stream)
}
inline ::jukey::prot::NetStream* NegotiateReq::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* NegotiateReq::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.NegotiateReq.stream)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* NegotiateReq::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* NegotiateReq::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.NegotiateReq.stream)
  return _msg;
}
inline void NegotiateReq::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.NegotiateReq.stream)
}

// required uint32 channel_id = 2;
inline bool NegotiateReq::_internal_has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NegotiateReq::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void NegotiateReq::clear_channel_id() {
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t NegotiateReq::_internal_channel_id() const {
  return _impl_.channel_id_;
}
inline uint32_t NegotiateReq::channel_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.NegotiateReq.channel_id)
  return _internal_channel_id();
}
inline void NegotiateReq::_internal_set_channel_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.channel_id_ = value;
}
inline void NegotiateReq::set_channel_id(uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.NegotiateReq.channel_id)
}

// repeated string caps = 3;
inline int NegotiateReq::_internal_caps_size() const {
  return _impl_.caps_.size();
}
inline int NegotiateReq::caps_size() const {
  return _internal_caps_size();
}
inline void NegotiateReq::clear_caps() {
  _impl_.caps_.Clear();
}
inline std::string* NegotiateReq::add_caps() {
  std::string* _s = _internal_add_caps();
  // @@protoc_insertion_point(field_add_mutable:jukey.prot.NegotiateReq.caps)
  return _s;
}
inline const std::string& NegotiateReq::_internal_caps(int index) const {
  return _impl_.caps_.Get(index);
}
inline const std::string& NegotiateReq::caps(int index) const {
  // @@protoc_insertion_point(field_get:jukey.prot.NegotiateReq.caps)
  return _internal_caps(index);
}
inline std::string* NegotiateReq::mutable_caps(int index) {
  // @@protoc_insertion_point(field_mutable:jukey.prot.NegotiateReq.caps)
  return _impl_.caps_.Mutable(index);
}
inline void NegotiateReq::set_caps(int index, const std::string& value) {
  _impl_.caps_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:jukey.prot.NegotiateReq.caps)
}
inline void NegotiateReq::set_caps(int index, std::string&& value) {
  _impl_.caps_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:jukey.prot.NegotiateReq.caps)
}
inline void NegotiateReq::set_caps(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.caps_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:jukey.prot.NegotiateReq.caps)
}
inline void NegotiateReq::set_caps(int index, const char* value, size_t size) {
  _impl_.caps_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:jukey.prot.NegotiateReq.caps)
}
inline std::string* NegotiateReq::_internal_add_caps() {
  return _impl_.caps_.Add();
}
inline void NegotiateReq::add_caps(const std::string& value) {
  _impl_.caps_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:jukey.prot.NegotiateReq.caps)
}
inline void NegotiateReq::add_caps(std::string&& value) {
  _impl_.caps_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:jukey.prot.NegotiateReq.caps)
}
inline void NegotiateReq::add_caps(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.caps_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:jukey.prot.NegotiateReq.caps)
}
inline void NegotiateReq::add_caps(const char* value, size_t size) {
  _impl_.caps_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:jukey.prot.NegotiateReq.caps)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NegotiateReq::caps() const {
  // @@protoc_insertion_point(field_list:jukey.prot.NegotiateReq.caps)
  return _impl_.caps_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NegotiateReq::mutable_caps() {
  // @@protoc_insertion_point(field_mutable_list:jukey.prot.NegotiateReq.caps)
  return &_impl_.caps_;
}

// -------------------------------------------------------------------

// NegotiateRsp

// required .jukey.prot.NetStream stream = 1;
inline bool NegotiateRsp::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool NegotiateRsp::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& NegotiateRsp::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& NegotiateRsp::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.NegotiateRsp.stream)
  return _internal_stream();
}
inline void NegotiateRsp::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.NegotiateRsp.stream)
}
inline ::jukey::prot::NetStream* NegotiateRsp::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* NegotiateRsp::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.NegotiateRsp.stream)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* NegotiateRsp::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* NegotiateRsp::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.NegotiateRsp.stream)
  return _msg;
}
inline void NegotiateRsp::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.NegotiateRsp.stream)
}

// required uint32 channel_id = 2;
inline bool NegotiateRsp::_internal_has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NegotiateRsp::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void NegotiateRsp::clear_channel_id() {
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t NegotiateRsp::_internal_channel_id() const {
  return _impl_.channel_id_;
}
inline uint32_t NegotiateRsp::channel_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.NegotiateRsp.channel_id)
  return _internal_channel_id();
}
inline void NegotiateRsp::_internal_set_channel_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.channel_id_ = value;
}
inline void NegotiateRsp::set_channel_id(uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.NegotiateRsp.channel_id)
}

// required string cap = 3;
inline bool NegotiateRsp::_internal_has_cap() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NegotiateRsp::has_cap() const {
  return _internal_has_cap();
}
inline void NegotiateRsp::clear_cap() {
  _impl_.cap_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NegotiateRsp::cap() const {
  // @@protoc_insertion_point(field_get:jukey.prot.NegotiateRsp.cap)
  return _internal_cap();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NegotiateRsp::set_cap(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.cap_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.NegotiateRsp.cap)
}
inline std::string* NegotiateRsp::mutable_cap() {
  std::string* _s = _internal_mutable_cap();
  // @@protoc_insertion_point(field_mutable:jukey.prot.NegotiateRsp.cap)
  return _s;
}
inline const std::string& NegotiateRsp::_internal_cap() const {
  return _impl_.cap_.Get();
}
inline void NegotiateRsp::_internal_set_cap(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cap_.Set(value, GetArenaForAllocation());
}
inline std::string* NegotiateRsp::_internal_mutable_cap() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.cap_.Mutable(GetArenaForAllocation());
}
inline std::string* NegotiateRsp::release_cap() {
  // @@protoc_insertion_point(field_release:jukey.prot.NegotiateRsp.cap)
  if (!_internal_has_cap()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.cap_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cap_.IsDefault()) {
    _impl_.cap_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NegotiateRsp::set_allocated_cap(std::string* cap) {
  if (cap != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cap_.SetAllocated(cap, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cap_.IsDefault()) {
    _impl_.cap_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.NegotiateRsp.cap)
}

// required uint32 result = 4;
inline bool NegotiateRsp::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NegotiateRsp::has_result() const {
  return _internal_has_result();
}
inline void NegotiateRsp::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t NegotiateRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t NegotiateRsp::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.NegotiateRsp.result)
  return _internal_result();
}
inline void NegotiateRsp::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.result_ = value;
}
inline void NegotiateRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.NegotiateRsp.result)
}

// required string msg = 5;
inline bool NegotiateRsp::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NegotiateRsp::has_msg() const {
  return _internal_has_msg();
}
inline void NegotiateRsp::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NegotiateRsp::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.NegotiateRsp.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NegotiateRsp::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.NegotiateRsp.msg)
}
inline std::string* NegotiateRsp::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.NegotiateRsp.msg)
  return _s;
}
inline const std::string& NegotiateRsp::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void NegotiateRsp::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* NegotiateRsp::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* NegotiateRsp::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.NegotiateRsp.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NegotiateRsp::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.NegotiateRsp.msg)
}

// -------------------------------------------------------------------

// StartSendStreamNotify

// required .jukey.prot.NetStream stream = 1;
inline bool StartSendStreamNotify::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool StartSendStreamNotify::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& StartSendStreamNotify::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& StartSendStreamNotify::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.StartSendStreamNotify.stream)
  return _internal_stream();
}
inline void StartSendStreamNotify::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.StartSendStreamNotify.stream)
}
inline ::jukey::prot::NetStream* StartSendStreamNotify::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* StartSendStreamNotify::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.StartSendStreamNotify.stream)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* StartSendStreamNotify::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* StartSendStreamNotify::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.StartSendStreamNotify.stream)
  return _msg;
}
inline void StartSendStreamNotify::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.StartSendStreamNotify.stream)
}

// required uint32 channel_id = 2;
inline bool StartSendStreamNotify::_internal_has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StartSendStreamNotify::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void StartSendStreamNotify::clear_channel_id() {
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t StartSendStreamNotify::_internal_channel_id() const {
  return _impl_.channel_id_;
}
inline uint32_t StartSendStreamNotify::channel_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.StartSendStreamNotify.channel_id)
  return _internal_channel_id();
}
inline void StartSendStreamNotify::_internal_set_channel_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.channel_id_ = value;
}
inline void StartSendStreamNotify::set_channel_id(uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.StartSendStreamNotify.channel_id)
}

// -------------------------------------------------------------------

// StartSendStreamAck

// required .jukey.prot.NetStream stream = 1;
inline bool StartSendStreamAck::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool StartSendStreamAck::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& StartSendStreamAck::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& StartSendStreamAck::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.StartSendStreamAck.stream)
  return _internal_stream();
}
inline void StartSendStreamAck::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.StartSendStreamAck.stream)
}
inline ::jukey::prot::NetStream* StartSendStreamAck::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* StartSendStreamAck::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.StartSendStreamAck.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* StartSendStreamAck::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* StartSendStreamAck::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.StartSendStreamAck.stream)
  return _msg;
}
inline void StartSendStreamAck::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.StartSendStreamAck.stream)
}

// required uint32 channel_id = 2;
inline bool StartSendStreamAck::_internal_has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StartSendStreamAck::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void StartSendStreamAck::clear_channel_id() {
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t StartSendStreamAck::_internal_channel_id() const {
  return _impl_.channel_id_;
}
inline uint32_t StartSendStreamAck::channel_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.StartSendStreamAck.channel_id)
  return _internal_channel_id();
}
inline void StartSendStreamAck::_internal_set_channel_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.channel_id_ = value;
}
inline void StartSendStreamAck::set_channel_id(uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.StartSendStreamAck.channel_id)
}

// required uint32 result = 3;
inline bool StartSendStreamAck::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StartSendStreamAck::has_result() const {
  return _internal_has_result();
}
inline void StartSendStreamAck::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t StartSendStreamAck::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t StartSendStreamAck::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.StartSendStreamAck.result)
  return _internal_result();
}
inline void StartSendStreamAck::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.result_ = value;
}
inline void StartSendStreamAck::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.StartSendStreamAck.result)
}

// required string msg = 4;
inline bool StartSendStreamAck::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StartSendStreamAck::has_msg() const {
  return _internal_has_msg();
}
inline void StartSendStreamAck::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StartSendStreamAck::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.StartSendStreamAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartSendStreamAck::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.StartSendStreamAck.msg)
}
inline std::string* StartSendStreamAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.StartSendStreamAck.msg)
  return _s;
}
inline const std::string& StartSendStreamAck::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void StartSendStreamAck::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* StartSendStreamAck::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* StartSendStreamAck::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.StartSendStreamAck.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StartSendStreamAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.StartSendStreamAck.msg)
}

// -------------------------------------------------------------------

// StopSendStreamNotify

// required .jukey.prot.NetStream stream = 1;
inline bool StopSendStreamNotify::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool StopSendStreamNotify::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& StopSendStreamNotify::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& StopSendStreamNotify::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.StopSendStreamNotify.stream)
  return _internal_stream();
}
inline void StopSendStreamNotify::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.StopSendStreamNotify.stream)
}
inline ::jukey::prot::NetStream* StopSendStreamNotify::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* StopSendStreamNotify::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.StopSendStreamNotify.stream)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* StopSendStreamNotify::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* StopSendStreamNotify::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.StopSendStreamNotify.stream)
  return _msg;
}
inline void StopSendStreamNotify::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.StopSendStreamNotify.stream)
}

// required uint32 channel_id = 2;
inline bool StopSendStreamNotify::_internal_has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StopSendStreamNotify::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void StopSendStreamNotify::clear_channel_id() {
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t StopSendStreamNotify::_internal_channel_id() const {
  return _impl_.channel_id_;
}
inline uint32_t StopSendStreamNotify::channel_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.StopSendStreamNotify.channel_id)
  return _internal_channel_id();
}
inline void StopSendStreamNotify::_internal_set_channel_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.channel_id_ = value;
}
inline void StopSendStreamNotify::set_channel_id(uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.StopSendStreamNotify.channel_id)
}

// -------------------------------------------------------------------

// StopSendStreamAck

// required .jukey.prot.NetStream stream = 1;
inline bool StopSendStreamAck::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool StopSendStreamAck::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& StopSendStreamAck::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& StopSendStreamAck::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.StopSendStreamAck.stream)
  return _internal_stream();
}
inline void StopSendStreamAck::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.StopSendStreamAck.stream)
}
inline ::jukey::prot::NetStream* StopSendStreamAck::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* StopSendStreamAck::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.StopSendStreamAck.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* StopSendStreamAck::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* StopSendStreamAck::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.StopSendStreamAck.stream)
  return _msg;
}
inline void StopSendStreamAck::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.StopSendStreamAck.stream)
}

// required uint32 channel_id = 2;
inline bool StopSendStreamAck::_internal_has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StopSendStreamAck::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void StopSendStreamAck::clear_channel_id() {
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t StopSendStreamAck::_internal_channel_id() const {
  return _impl_.channel_id_;
}
inline uint32_t StopSendStreamAck::channel_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.StopSendStreamAck.channel_id)
  return _internal_channel_id();
}
inline void StopSendStreamAck::_internal_set_channel_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.channel_id_ = value;
}
inline void StopSendStreamAck::set_channel_id(uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.StopSendStreamAck.channel_id)
}

// required uint32 result = 3;
inline bool StopSendStreamAck::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StopSendStreamAck::has_result() const {
  return _internal_has_result();
}
inline void StopSendStreamAck::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t StopSendStreamAck::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t StopSendStreamAck::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.StopSendStreamAck.result)
  return _internal_result();
}
inline void StopSendStreamAck::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.result_ = value;
}
inline void StopSendStreamAck::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.StopSendStreamAck.result)
}

// required string msg = 4;
inline bool StopSendStreamAck::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StopSendStreamAck::has_msg() const {
  return _internal_has_msg();
}
inline void StopSendStreamAck::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StopSendStreamAck::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.StopSendStreamAck.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopSendStreamAck::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.StopSendStreamAck.msg)
}
inline std::string* StopSendStreamAck::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.StopSendStreamAck.msg)
  return _s;
}
inline const std::string& StopSendStreamAck::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void StopSendStreamAck::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* StopSendStreamAck::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* StopSendStreamAck::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.StopSendStreamAck.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StopSendStreamAck::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.StopSendStreamAck.msg)
}

// -------------------------------------------------------------------

// PauseRecvStreamReq

// required .jukey.prot.NetStream stream = 1;
inline bool PauseRecvStreamReq::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool PauseRecvStreamReq::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& PauseRecvStreamReq::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& PauseRecvStreamReq::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.PauseRecvStreamReq.stream)
  return _internal_stream();
}
inline void PauseRecvStreamReq::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.PauseRecvStreamReq.stream)
}
inline ::jukey::prot::NetStream* PauseRecvStreamReq::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* PauseRecvStreamReq::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.PauseRecvStreamReq.stream)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* PauseRecvStreamReq::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* PauseRecvStreamReq::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.PauseRecvStreamReq.stream)
  return _msg;
}
inline void PauseRecvStreamReq::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.PauseRecvStreamReq.stream)
}

// required uint32 channel_id = 2;
inline bool PauseRecvStreamReq::_internal_has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PauseRecvStreamReq::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void PauseRecvStreamReq::clear_channel_id() {
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t PauseRecvStreamReq::_internal_channel_id() const {
  return _impl_.channel_id_;
}
inline uint32_t PauseRecvStreamReq::channel_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.PauseRecvStreamReq.channel_id)
  return _internal_channel_id();
}
inline void PauseRecvStreamReq::_internal_set_channel_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.channel_id_ = value;
}
inline void PauseRecvStreamReq::set_channel_id(uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.PauseRecvStreamReq.channel_id)
}

// -------------------------------------------------------------------

// PauseRecvStreamRsp

// required .jukey.prot.NetStream stream = 1;
inline bool PauseRecvStreamRsp::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool PauseRecvStreamRsp::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& PauseRecvStreamRsp::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& PauseRecvStreamRsp::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.PauseRecvStreamRsp.stream)
  return _internal_stream();
}
inline void PauseRecvStreamRsp::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.PauseRecvStreamRsp.stream)
}
inline ::jukey::prot::NetStream* PauseRecvStreamRsp::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* PauseRecvStreamRsp::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.PauseRecvStreamRsp.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* PauseRecvStreamRsp::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* PauseRecvStreamRsp::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.PauseRecvStreamRsp.stream)
  return _msg;
}
inline void PauseRecvStreamRsp::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.PauseRecvStreamRsp.stream)
}

// required uint32 channel_id = 2;
inline bool PauseRecvStreamRsp::_internal_has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PauseRecvStreamRsp::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void PauseRecvStreamRsp::clear_channel_id() {
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t PauseRecvStreamRsp::_internal_channel_id() const {
  return _impl_.channel_id_;
}
inline uint32_t PauseRecvStreamRsp::channel_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.PauseRecvStreamRsp.channel_id)
  return _internal_channel_id();
}
inline void PauseRecvStreamRsp::_internal_set_channel_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.channel_id_ = value;
}
inline void PauseRecvStreamRsp::set_channel_id(uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.PauseRecvStreamRsp.channel_id)
}

// required uint32 result = 3;
inline bool PauseRecvStreamRsp::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PauseRecvStreamRsp::has_result() const {
  return _internal_has_result();
}
inline void PauseRecvStreamRsp::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t PauseRecvStreamRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t PauseRecvStreamRsp::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.PauseRecvStreamRsp.result)
  return _internal_result();
}
inline void PauseRecvStreamRsp::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.result_ = value;
}
inline void PauseRecvStreamRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.PauseRecvStreamRsp.result)
}

// required string msg = 4;
inline bool PauseRecvStreamRsp::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PauseRecvStreamRsp::has_msg() const {
  return _internal_has_msg();
}
inline void PauseRecvStreamRsp::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PauseRecvStreamRsp::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.PauseRecvStreamRsp.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PauseRecvStreamRsp::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.PauseRecvStreamRsp.msg)
}
inline std::string* PauseRecvStreamRsp::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.PauseRecvStreamRsp.msg)
  return _s;
}
inline const std::string& PauseRecvStreamRsp::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void PauseRecvStreamRsp::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* PauseRecvStreamRsp::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* PauseRecvStreamRsp::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.PauseRecvStreamRsp.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PauseRecvStreamRsp::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.PauseRecvStreamRsp.msg)
}

// -------------------------------------------------------------------

// ResumeRecvStreamReq

// required .jukey.prot.NetStream stream = 1;
inline bool ResumeRecvStreamReq::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool ResumeRecvStreamReq::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& ResumeRecvStreamReq::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& ResumeRecvStreamReq::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.ResumeRecvStreamReq.stream)
  return _internal_stream();
}
inline void ResumeRecvStreamReq::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.ResumeRecvStreamReq.stream)
}
inline ::jukey::prot::NetStream* ResumeRecvStreamReq::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* ResumeRecvStreamReq::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.ResumeRecvStreamReq.stream)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* ResumeRecvStreamReq::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* ResumeRecvStreamReq::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.ResumeRecvStreamReq.stream)
  return _msg;
}
inline void ResumeRecvStreamReq::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.ResumeRecvStreamReq.stream)
}

// required uint32 channel_id = 2;
inline bool ResumeRecvStreamReq::_internal_has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResumeRecvStreamReq::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void ResumeRecvStreamReq::clear_channel_id() {
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ResumeRecvStreamReq::_internal_channel_id() const {
  return _impl_.channel_id_;
}
inline uint32_t ResumeRecvStreamReq::channel_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.ResumeRecvStreamReq.channel_id)
  return _internal_channel_id();
}
inline void ResumeRecvStreamReq::_internal_set_channel_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.channel_id_ = value;
}
inline void ResumeRecvStreamReq::set_channel_id(uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.ResumeRecvStreamReq.channel_id)
}

// -------------------------------------------------------------------

// ResumeRecvStreamRsp

// required .jukey.prot.NetStream stream = 1;
inline bool ResumeRecvStreamRsp::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool ResumeRecvStreamRsp::has_stream() const {
  return _internal_has_stream();
}
inline const ::jukey::prot::NetStream& ResumeRecvStreamRsp::_internal_stream() const {
  const ::jukey::prot::NetStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::jukey::prot::NetStream&>(
      ::jukey::prot::_NetStream_default_instance_);
}
inline const ::jukey::prot::NetStream& ResumeRecvStreamRsp::stream() const {
  // @@protoc_insertion_point(field_get:jukey.prot.ResumeRecvStreamRsp.stream)
  return _internal_stream();
}
inline void ResumeRecvStreamRsp::unsafe_arena_set_allocated_stream(
    ::jukey::prot::NetStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:jukey.prot.ResumeRecvStreamRsp.stream)
}
inline ::jukey::prot::NetStream* ResumeRecvStreamRsp::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::jukey::prot::NetStream* ResumeRecvStreamRsp::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:jukey.prot.ResumeRecvStreamRsp.stream)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::jukey::prot::NetStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::jukey::prot::NetStream* ResumeRecvStreamRsp::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::jukey::prot::NetStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::jukey::prot::NetStream* ResumeRecvStreamRsp::mutable_stream() {
  ::jukey::prot::NetStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:jukey.prot.ResumeRecvStreamRsp.stream)
  return _msg;
}
inline void ResumeRecvStreamRsp::set_allocated_stream(::jukey::prot::NetStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.ResumeRecvStreamRsp.stream)
}

// required uint32 channel_id = 2;
inline bool ResumeRecvStreamRsp::_internal_has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ResumeRecvStreamRsp::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void ResumeRecvStreamRsp::clear_channel_id() {
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ResumeRecvStreamRsp::_internal_channel_id() const {
  return _impl_.channel_id_;
}
inline uint32_t ResumeRecvStreamRsp::channel_id() const {
  // @@protoc_insertion_point(field_get:jukey.prot.ResumeRecvStreamRsp.channel_id)
  return _internal_channel_id();
}
inline void ResumeRecvStreamRsp::_internal_set_channel_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.channel_id_ = value;
}
inline void ResumeRecvStreamRsp::set_channel_id(uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:jukey.prot.ResumeRecvStreamRsp.channel_id)
}

// required uint32 result = 3;
inline bool ResumeRecvStreamRsp::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ResumeRecvStreamRsp::has_result() const {
  return _internal_has_result();
}
inline void ResumeRecvStreamRsp::clear_result() {
  _impl_.result_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ResumeRecvStreamRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t ResumeRecvStreamRsp::result() const {
  // @@protoc_insertion_point(field_get:jukey.prot.ResumeRecvStreamRsp.result)
  return _internal_result();
}
inline void ResumeRecvStreamRsp::_internal_set_result(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.result_ = value;
}
inline void ResumeRecvStreamRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:jukey.prot.ResumeRecvStreamRsp.result)
}

// required string msg = 4;
inline bool ResumeRecvStreamRsp::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResumeRecvStreamRsp::has_msg() const {
  return _internal_has_msg();
}
inline void ResumeRecvStreamRsp::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResumeRecvStreamRsp::msg() const {
  // @@protoc_insertion_point(field_get:jukey.prot.ResumeRecvStreamRsp.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResumeRecvStreamRsp::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:jukey.prot.ResumeRecvStreamRsp.msg)
}
inline std::string* ResumeRecvStreamRsp::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:jukey.prot.ResumeRecvStreamRsp.msg)
  return _s;
}
inline const std::string& ResumeRecvStreamRsp::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void ResumeRecvStreamRsp::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* ResumeRecvStreamRsp::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* ResumeRecvStreamRsp::release_msg() {
  // @@protoc_insertion_point(field_release:jukey.prot.ResumeRecvStreamRsp.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResumeRecvStreamRsp::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:jukey.prot.ResumeRecvStreamRsp.msg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace prot
}  // namespace jukey

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_transport_2eproto
